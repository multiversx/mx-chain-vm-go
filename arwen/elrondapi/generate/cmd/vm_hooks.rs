// Code generated by elrondapi generator. DO NOT EDIT.

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!! AUTO-GENERATED FILE !!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

pub trait VMHooks: 'static {
    fn get_gas_left(&self) -> i64;
    fn get_sc_address(&self, result_offset: i32);
    fn get_owner_address(&self, result_offset: i32);
    fn get_shard_of_address(&self, address_offset: i32) -> i32;
    fn is_smart_contract(&self, address_offset: i32) -> i32;
    fn signal_error(&self, message_offset: i32, message_length: i32);
    fn get_external_balance(&self, address_offset: i32, result_offset: i32);
    fn get_block_hash(&self, nonce: i64, result_offset: i32) -> i32;
    fn get_esdt_balance(&self, address_offset: i32, token_id_offset: i32, token_id_len: i32, nonce: i64, result_offset: i32) -> i32;
    fn get_esdt_nft_name_length(&self, address_offset: i32, token_id_offset: i32, token_id_len: i32, nonce: i64) -> i32;
    fn get_esdt_nft_attribute_length(&self, address_offset: i32, token_id_offset: i32, token_id_len: i32, nonce: i64) -> i32;
    fn get_esdt_nft_uri_length(&self, address_offset: i32, token_id_offset: i32, token_id_len: i32, nonce: i64) -> i32;
    fn get_esdt_token_data(&self, address_offset: i32, token_id_offset: i32, token_id_len: i32, nonce: i64, value_handle: i32, properties_offset: i32, hash_offset: i32, name_offset: i32, attributes_offset: i32, creator_offset: i32, royalties_handle: i32, uris_offset: i32) -> i32;
    fn get_esdt_local_roles(&self, token_id_handle: i32) -> i64;
    fn validate_token_identifier(&self, token_id_handle: i32) -> i32;
    fn transfer_value(&self, dest_offset: i32, value_offset: i32, data_offset: i32, length: i32) -> i32;
    fn transfer_value_execute(&self, dest_offset: i32, value_offset: i32, gas_limit: i64, function_offset: i32, function_length: i32, num_arguments: i32, arguments_length_offset: i32, data_offset: i32) -> i32;
    fn transfer_esdt_execute(&self, dest_offset: i32, token_id_offset: i32, token_id_len: i32, value_offset: i32, gas_limit: i64, function_offset: i32, function_length: i32, num_arguments: i32, arguments_length_offset: i32, data_offset: i32) -> i32;
    fn transfer_esdt_nft_execute(&self, dest_offset: i32, token_id_offset: i32, token_id_len: i32, value_offset: i32, nonce: i64, gas_limit: i64, function_offset: i32, function_length: i32, num_arguments: i32, arguments_length_offset: i32, data_offset: i32) -> i32;
    fn multi_transfer_esdt_nft_execute(&self, dest_offset: i32, num_token_transfers: i32, token_transfers_args_length_offset: i32, token_transfer_data_offset: i32, gas_limit: i64, function_offset: i32, function_length: i32, num_arguments: i32, arguments_length_offset: i32, data_offset: i32) -> i32;
    fn create_async_call(&self, dest_offset: i32, value_offset: i32, data_offset: i32, data_length: i32, success_offset: i32, success_length: i32, error_offset: i32, error_length: i32, gas: i64, extra_gas_for_callback: i64) -> i32;
    fn set_async_context_callback(&self, callback: i32, callback_length: i32, data: i32, data_length: i32, gas: i64) -> i32;
    fn upgrade_contract(&self, dest_offset: i32, gas_limit: i64, value_offset: i32, code_offset: i32, code_metadata_offset: i32, length: i32, num_arguments: i32, arguments_length_offset: i32, data_offset: i32);
    fn upgrade_from_source_contract(&self, dest_offset: i32, gas_limit: i64, value_offset: i32, source_contract_address_offset: i32, code_metadata_offset: i32, num_arguments: i32, arguments_length_offset: i32, data_offset: i32);
    fn delete_contract(&self, dest_offset: i32, gas_limit: i64, num_arguments: i32, arguments_length_offset: i32, data_offset: i32);
    fn async_call(&self, dest_offset: i32, value_offset: i32, data_offset: i32, length: i32);
    fn get_argument_length(&self, id: i32) -> i32;
    fn get_argument(&self, id: i32, arg_offset: i32) -> i32;
    fn get_function(&self, function_offset: i32) -> i32;
    fn get_num_arguments(&self) -> i32;
    fn storage_store(&self, key_offset: i32, key_length: i32, data_offset: i32, data_length: i32) -> i32;
    fn storage_load_length(&self, key_offset: i32, key_length: i32) -> i32;
    fn storage_load_from_address(&self, address_offset: i32, key_offset: i32, key_length: i32, data_offset: i32) -> i32;
    fn storage_load(&self, key_offset: i32, key_length: i32, data_offset: i32) -> i32;
    fn set_storage_lock(&self, key_offset: i32, key_length: i32, lock_timestamp: i64) -> i32;
    fn get_storage_lock(&self, key_offset: i32, key_length: i32) -> i64;
    fn is_storage_locked(&self, key_offset: i32, key_length: i32) -> i32;
    fn clear_storage_lock(&self, key_offset: i32, key_length: i32) -> i32;
    fn get_caller(&self, result_offset: i32);
    fn check_no_payment(&self);
    fn get_call_value(&self, result_offset: i32) -> i32;
    fn get_esdt_value(&self, result_offset: i32) -> i32;
    fn get_esdt_value_by_index(&self, result_offset: i32, index: i32) -> i32;
    fn get_esdt_token_name(&self, result_offset: i32) -> i32;
    fn get_esdt_token_name_by_index(&self, result_offset: i32, index: i32) -> i32;
    fn get_esdt_token_nonce(&self) -> i64;
    fn get_esdt_token_nonce_by_index(&self, index: i32) -> i64;
    fn get_current_esdt_nft_nonce(&self, address_offset: i32, token_id_offset: i32, token_id_len: i32) -> i64;
    fn get_esdt_token_type(&self) -> i32;
    fn get_esdt_token_type_by_index(&self, index: i32) -> i32;
    fn get_num_esdt_transfers(&self) -> i32;
    fn get_call_value_token_name(&self, call_value_offset: i32, token_name_offset: i32) -> i32;
    fn get_call_value_token_name_by_index(&self, call_value_offset: i32, token_name_offset: i32, index: i32) -> i32;
    fn write_log(&self, data_pointer: i32, data_length: i32, topic_ptr: i32, num_topics: i32);
    fn write_event_log(&self, num_topics: i32, topic_lengths_offset: i32, topic_offset: i32, data_offset: i32, data_length: i32);
    fn get_block_timestamp(&self) -> i64;
    fn get_block_nonce(&self) -> i64;
    fn get_block_round(&self) -> i64;
    fn get_block_epoch(&self) -> i64;
    fn get_block_random_seed(&self, pointer: i32);
    fn get_state_root_hash(&self, pointer: i32);
    fn get_prev_block_timestamp(&self) -> i64;
    fn get_prev_block_nonce(&self) -> i64;
    fn get_prev_block_round(&self) -> i64;
    fn get_prev_block_epoch(&self) -> i64;
    fn get_prev_block_random_seed(&self, pointer: i32);
    fn finish(&self, pointer: i32, length: i32);
    fn execute_on_same_context(&self, gas_limit: i64, address_offset: i32, value_offset: i32, function_offset: i32, function_length: i32, num_arguments: i32, arguments_length_offset: i32, data_offset: i32) -> i32;
    fn execute_on_dest_context(&self, gas_limit: i64, address_offset: i32, value_offset: i32, function_offset: i32, function_length: i32, num_arguments: i32, arguments_length_offset: i32, data_offset: i32) -> i32;
    fn execute_read_only(&self, gas_limit: i64, address_offset: i32, function_offset: i32, function_length: i32, num_arguments: i32, arguments_length_offset: i32, data_offset: i32) -> i32;
    fn create_contract(&self, gas_limit: i64, value_offset: i32, code_offset: i32, code_metadata_offset: i32, length: i32, result_offset: i32, num_arguments: i32, arguments_length_offset: i32, data_offset: i32) -> i32;
    fn deploy_from_source_contract(&self, gas_limit: i64, value_offset: i32, source_contract_address_offset: i32, code_metadata_offset: i32, result_address_offset: i32, num_arguments: i32, arguments_length_offset: i32, data_offset: i32) -> i32;
    fn get_num_return_data(&self) -> i32;
    fn get_return_data_size(&self, result_id: i32) -> i32;
    fn get_return_data(&self, result_id: i32, data_offset: i32) -> i32;
    fn clean_return_data(&self);
    fn delete_from_return_data(&self, result_id: i32);
    fn get_original_tx_hash(&self, data_offset: i32);
    fn get_current_tx_hash(&self, data_offset: i32);
    fn get_prev_tx_hash(&self, data_offset: i32);
    fn managed_sc_address(&self, destination_handle: i32);
    fn managed_owner_address(&self, destination_handle: i32);
    fn managed_caller(&self, destination_handle: i32);
    fn managed_signal_error(&self, err_handle: i32);
    fn managed_write_log(&self, topics_handle: i32, data_handle: i32);
    fn managed_get_original_tx_hash(&self, result_handle: i32);
    fn managed_get_state_root_hash(&self, result_handle: i32);
    fn managed_get_block_random_seed(&self, result_handle: i32);
    fn managed_get_prev_block_random_seed(&self, result_handle: i32);
    fn managed_get_return_data(&self, result_id: i32, result_handle: i32);
    fn managed_get_multi_esdt_call_value(&self, multi_call_value_handle: i32);
    fn managed_get_esdt_balance(&self, address_handle: i32, token_id_handle: i32, nonce: i64, value_handle: i32);
    fn managed_get_esdt_token_data(&self, address_handle: i32, token_id_handle: i32, nonce: i64, value_handle: i32, properties_handle: i32, hash_handle: i32, name_handle: i32, attributes_handle: i32, creator_handle: i32, royalties_handle: i32, uris_handle: i32);
    fn managed_async_call(&self, dest_handle: i32, value_handle: i32, function_handle: i32, arguments_handle: i32);
    fn managed_create_async_call(&self, dest_handle: i32, value_handle: i32, function_handle: i32, arguments_handle: i32, success_offset: i32, success_length: i32, error_offset: i32, error_length: i32, gas: i64, extra_gas_for_callback: i64, callback_closure_handle: i32) -> i32;
    fn managed_get_callback_closure(&self, callback_closure_handle: i32);
    fn managed_upgrade_from_source_contract(&self, dest_handle: i32, gas: i64, value_handle: i32, address_handle: i32, code_metadata_handle: i32, arguments_handle: i32, result_handle: i32);
    fn managed_upgrade_contract(&self, dest_handle: i32, gas: i64, value_handle: i32, code_handle: i32, code_metadata_handle: i32, arguments_handle: i32, result_handle: i32);
    fn managed_delete_contract(&self, dest_handle: i32, gas_limit: i64, arguments_handle: i32);
    fn managed_deploy_from_source_contract(&self, gas: i64, value_handle: i32, address_handle: i32, code_metadata_handle: i32, arguments_handle: i32, result_address_handle: i32, result_handle: i32) -> i32;
    fn managed_create_contract(&self, gas: i64, value_handle: i32, code_handle: i32, code_metadata_handle: i32, arguments_handle: i32, result_address_handle: i32, result_handle: i32) -> i32;
    fn managed_execute_read_only(&self, gas: i64, address_handle: i32, function_handle: i32, arguments_handle: i32, result_handle: i32) -> i32;
    fn managed_execute_on_same_context(&self, gas: i64, address_handle: i32, value_handle: i32, function_handle: i32, arguments_handle: i32, result_handle: i32) -> i32;
    fn managed_execute_on_dest_context(&self, gas: i64, address_handle: i32, value_handle: i32, function_handle: i32, arguments_handle: i32, result_handle: i32) -> i32;
    fn managed_multi_transfer_esdt_nft_execute(&self, dst_handle: i32, token_transfers_handle: i32, gas_limit: i64, function_handle: i32, arguments_handle: i32) -> i32;
    fn managed_transfer_value_execute(&self, dst_handle: i32, value_handle: i32, gas_limit: i64, function_handle: i32, arguments_handle: i32) -> i32;
    fn managed_is_esdt_frozen(&self, address_handle: i32, token_id_handle: i32, nonce: i64) -> i32;
    fn managed_is_esdt_limited_transfer(&self, token_id_handle: i32) -> i32;
    fn managed_is_esdt_paused(&self, token_id_handle: i32) -> i32;
    fn managed_buffer_to_hex(&self, source_handle: i32, dest_handle: i32);
    fn big_float_new_from_parts(&self, integral_part: i32, fractional_part: i32, exponent: i32) -> i32;
    fn big_float_new_from_frac(&self, numerator: i64, denominator: i64) -> i32;
    fn big_float_new_from_sci(&self, significand: i64, exponent: i64) -> i32;
    fn big_float_add(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32);
    fn big_float_sub(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32);
    fn big_float_mul(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32);
    fn big_float_div(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32);
    fn big_float_neg(&self, destination_handle: i32, op_handle: i32);
    fn big_float_clone(&self, destination_handle: i32, op_handle: i32);
    fn big_float_cmp(&self, op1_handle: i32, op2_handle: i32) -> i32;
    fn big_float_abs(&self, destination_handle: i32, op_handle: i32);
    fn big_float_sign(&self, op_handle: i32) -> i32;
    fn big_float_sqrt(&self, destination_handle: i32, op_handle: i32);
    fn big_float_pow(&self, destination_handle: i32, op_handle: i32, exponent: i32);
    fn big_float_floor(&self, dest_big_int_handle: i32, op_handle: i32);
    fn big_float_ceil(&self, dest_big_int_handle: i32, op_handle: i32);
    fn big_float_truncate(&self, dest_big_int_handle: i32, op_handle: i32);
    fn big_float_set_int64(&self, destination_handle: i32, value: i64);
    fn big_float_is_int(&self, op_handle: i32) -> i32;
    fn big_float_set_big_int(&self, destination_handle: i32, big_int_handle: i32);
    fn big_float_get_const_pi(&self, destination_handle: i32);
    fn big_float_get_const_e(&self, destination_handle: i32);
    fn big_int_get_unsigned_argument(&self, id: i32, destination_handle: i32);
    fn big_int_get_signed_argument(&self, id: i32, destination_handle: i32);
    fn big_int_storage_store_unsigned(&self, key_offset: i32, key_length: i32, source_handle: i32) -> i32;
    fn big_int_storage_load_unsigned(&self, key_offset: i32, key_length: i32, destination_handle: i32) -> i32;
    fn big_int_get_call_value(&self, destination_handle: i32);
    fn big_int_get_esdt_call_value(&self, destination: i32);
    fn big_int_get_esdt_call_value_by_index(&self, destination_handle: i32, index: i32);
    fn big_int_get_external_balance(&self, address_offset: i32, result: i32);
    fn big_int_get_esdt_external_balance(&self, address_offset: i32, token_id_offset: i32, token_id_len: i32, nonce: i64, result_handle: i32);
    fn big_int_new(&self, small_value: i64) -> i32;
    fn big_int_unsigned_byte_length(&self, reference_handle: i32) -> i32;
    fn big_int_signed_byte_length(&self, reference_handle: i32) -> i32;
    fn big_int_get_unsigned_bytes(&self, reference_handle: i32, byte_offset: i32) -> i32;
    fn big_int_get_signed_bytes(&self, reference_handle: i32, byte_offset: i32) -> i32;
    fn big_int_set_unsigned_bytes(&self, destination_handle: i32, byte_offset: i32, byte_length: i32);
    fn big_int_set_signed_bytes(&self, destination_handle: i32, byte_offset: i32, byte_length: i32);
    fn big_int_is_int64(&self, destination_handle: i32) -> i32;
    fn big_int_get_int64(&self, destination_handle: i32) -> i64;
    fn big_int_set_int64(&self, destination_handle: i32, value: i64);
    fn big_int_add(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32);
    fn big_int_sub(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32);
    fn big_int_mul(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32);
    fn big_int_tdiv(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32);
    fn big_int_tmod(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32);
    fn big_int_ediv(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32);
    fn big_int_emod(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32);
    fn big_int_sqrt(&self, destination_handle: i32, op_handle: i32);
    fn big_int_pow(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32);
    fn big_int_log2(&self, op1_handle: i32) -> i32;
    fn big_int_abs(&self, destination_handle: i32, op_handle: i32);
    fn big_int_neg(&self, destination_handle: i32, op_handle: i32);
    fn big_int_sign(&self, op_handle: i32) -> i32;
    fn big_int_cmp(&self, op1_handle: i32, op2_handle: i32) -> i32;
    fn big_int_not(&self, destination_handle: i32, op_handle: i32);
    fn big_int_and(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32);
    fn big_int_or(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32);
    fn big_int_xor(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32);
    fn big_int_shr(&self, destination_handle: i32, op_handle: i32, bits: i32);
    fn big_int_shl(&self, destination_handle: i32, op_handle: i32, bits: i32);
    fn big_int_finish_unsigned(&self, reference_handle: i32);
    fn big_int_finish_signed(&self, reference_handle: i32);
    fn big_int_to_string(&self, big_int_handle: i32, destination_handle: i32);
    fn mbuffer_new(&self) -> i32;
    fn mbuffer_new_from_bytes(&self, data_offset: i32, data_length: i32) -> i32;
    fn mbuffer_get_length(&self, m_buffer_handle: i32) -> i32;
    fn mbuffer_get_bytes(&self, m_buffer_handle: i32, result_offset: i32) -> i32;
    fn mbuffer_get_byte_slice(&self, source_handle: i32, starting_position: i32, slice_length: i32, result_offset: i32) -> i32;
    fn mbuffer_copy_byte_slice(&self, source_handle: i32, starting_position: i32, slice_length: i32, destination_handle: i32) -> i32;
    fn mbuffer_eq(&self, m_buffer_handle1: i32, m_buffer_handle2: i32) -> i32;
    fn mbuffer_set_bytes(&self, m_buffer_handle: i32, data_offset: i32, data_length: i32) -> i32;
    fn mbuffer_set_byte_slice(&self, m_buffer_handle: i32, starting_position: i32, data_length: i32, data_offset: i32) -> i32;
    fn mbuffer_append(&self, accumulator_handle: i32, data_handle: i32) -> i32;
    fn mbuffer_append_bytes(&self, accumulator_handle: i32, data_offset: i32, data_length: i32) -> i32;
    fn mbuffer_to_big_int_unsigned(&self, m_buffer_handle: i32, big_int_handle: i32) -> i32;
    fn mbuffer_to_big_int_signed(&self, m_buffer_handle: i32, big_int_handle: i32) -> i32;
    fn mbuffer_from_big_int_unsigned(&self, m_buffer_handle: i32, big_int_handle: i32) -> i32;
    fn mbuffer_from_big_int_signed(&self, m_buffer_handle: i32, big_int_handle: i32) -> i32;
    fn mbuffer_to_big_float(&self, m_buffer_handle: i32, big_float_handle: i32) -> i32;
    fn mbuffer_from_big_float(&self, m_buffer_handle: i32, big_float_handle: i32) -> i32;
    fn mbuffer_storage_store(&self, key_handle: i32, source_handle: i32) -> i32;
    fn mbuffer_storage_load(&self, key_handle: i32, destination_handle: i32) -> i32;
    fn mbuffer_storage_load_from_address(&self, address_handle: i32, key_handle: i32, destination_handle: i32);
    fn mbuffer_get_argument(&self, id: i32, destination_handle: i32) -> i32;
    fn mbuffer_finish(&self, source_handle: i32) -> i32;
    fn mbuffer_set_random(&self, destination_handle: i32, length: i32) -> i32;
    fn small_int_get_unsigned_argument(&self, id: i32) -> i64;
    fn small_int_get_signed_argument(&self, id: i32) -> i64;
    fn small_int_finish_unsigned(&self, value: i64);
    fn small_int_finish_signed(&self, value: i64);
    fn small_int_storage_store_unsigned(&self, key_offset: i32, key_length: i32, value: i64) -> i32;
    fn small_int_storage_store_signed(&self, key_offset: i32, key_length: i32, value: i64) -> i32;
    fn small_int_storage_load_unsigned(&self, key_offset: i32, key_length: i32) -> i64;
    fn small_int_storage_load_signed(&self, key_offset: i32, key_length: i32) -> i64;
    fn int64get_argument(&self, id: i32) -> i64;
    fn int64finish(&self, value: i64);
    fn int64storage_store(&self, key_offset: i32, key_length: i32, value: i64) -> i32;
    fn int64storage_load(&self, key_offset: i32, key_length: i32) -> i64;
    fn sha256(&self, data_offset: i32, length: i32, result_offset: i32) -> i32;
    fn managed_sha256(&self, input_handle: i32, output_handle: i32) -> i32;
    fn keccak256(&self, data_offset: i32, length: i32, result_offset: i32) -> i32;
    fn managed_keccak256(&self, input_handle: i32, output_handle: i32) -> i32;
    fn ripemd160(&self, data_offset: i32, length: i32, result_offset: i32) -> i32;
    fn managed_ripemd160(&self, input_handle: i32, output_handle: i32) -> i32;
    fn verify_bls(&self, key_offset: i32, message_offset: i32, message_length: i32, sig_offset: i32) -> i32;
    fn managed_verify_bls(&self, key_handle: i32, message_handle: i32, sig_handle: i32) -> i32;
    fn verify_ed25519(&self, key_offset: i32, message_offset: i32, message_length: i32, sig_offset: i32) -> i32;
    fn managed_verify_ed25519(&self, key_handle: i32, message_handle: i32, sig_handle: i32) -> i32;
    fn verify_custom_secp256k1(&self, key_offset: i32, key_length: i32, message_offset: i32, message_length: i32, sig_offset: i32, hash_type: i32) -> i32;
    fn managed_verify_custom_secp256k1(&self, key_handle: i32, message_handle: i32, sig_handle: i32, hash_type: i32) -> i32;
    fn verify_secp256k1(&self, key_offset: i32, key_length: i32, message_offset: i32, message_length: i32, sig_offset: i32) -> i32;
    fn managed_verify_secp256k1(&self, key_handle: i32, message_handle: i32, sig_handle: i32) -> i32;
    fn encode_secp256k1_der_signature(&self, r_offset: i32, r_length: i32, s_offset: i32, s_length: i32, sig_offset: i32) -> i32;
    fn managed_encode_secp256k1_der_signature(&self, r_handle: i32, s_handle: i32, sig_handle: i32) -> i32;
    fn add_ec(&self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, fst_point_xhandle: i32, fst_point_yhandle: i32, snd_point_xhandle: i32, snd_point_yhandle: i32);
    fn double_ec(&self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, point_xhandle: i32, point_yhandle: i32);
    fn is_on_curve_ec(&self, ec_handle: i32, point_xhandle: i32, point_yhandle: i32) -> i32;
    fn scalar_base_mult_ec(&self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, data_offset: i32, length: i32) -> i32;
    fn managed_scalar_base_mult_ec(&self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, data_handle: i32) -> i32;
    fn scalar_mult_ec(&self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, point_xhandle: i32, point_yhandle: i32, data_offset: i32, length: i32) -> i32;
    fn managed_scalar_mult_ec(&self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, point_xhandle: i32, point_yhandle: i32, data_handle: i32) -> i32;
    fn marshal_ec(&self, x_pair_handle: i32, y_pair_handle: i32, ec_handle: i32, result_offset: i32) -> i32;
    fn managed_marshal_ec(&self, x_pair_handle: i32, y_pair_handle: i32, ec_handle: i32, result_handle: i32) -> i32;
    fn marshal_compressed_ec(&self, x_pair_handle: i32, y_pair_handle: i32, ec_handle: i32, result_offset: i32) -> i32;
    fn managed_marshal_compressed_ec(&self, x_pair_handle: i32, y_pair_handle: i32, ec_handle: i32, result_handle: i32) -> i32;
    fn unmarshal_ec(&self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, data_offset: i32, length: i32) -> i32;
    fn managed_unmarshal_ec(&self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, data_handle: i32) -> i32;
    fn unmarshal_compressed_ec(&self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, data_offset: i32, length: i32) -> i32;
    fn managed_unmarshal_compressed_ec(&self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, data_handle: i32) -> i32;
    fn generate_key_ec(&self, x_pub_key_handle: i32, y_pub_key_handle: i32, ec_handle: i32, result_offset: i32) -> i32;
    fn managed_generate_key_ec(&self, x_pub_key_handle: i32, y_pub_key_handle: i32, ec_handle: i32, result_handle: i32) -> i32;
    fn create_ec(&self, data_offset: i32, data_length: i32) -> i32;
    fn managed_create_ec(&self, data_handle: i32) -> i32;
    fn get_curve_length_ec(&self, ec_handle: i32) -> i32;
    fn get_priv_key_byte_length_ec(&self, ec_handle: i32) -> i32;
    fn elliptic_curve_get_values(&self, ec_handle: i32, field_order_handle: i32, base_point_order_handle: i32, eq_constant_handle: i32, x_base_point_handle: i32, y_base_point_handle: i32) -> i32;
}
