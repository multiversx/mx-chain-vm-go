package hostCoretest

import (
	"bytes"
	"fmt"
	"math/big"
	"sort"
	"testing"

	"github.com/multiversx/mx-chain-core-go/data/vm"
	logger "github.com/multiversx/mx-chain-logger-go"
	"github.com/multiversx/mx-chain-scenario-go/worldmock"
	vmcommon "github.com/multiversx/mx-chain-vm-common-go"
	"github.com/multiversx/mx-chain-vm-common-go/parsers"
	"github.com/multiversx/mx-chain-vm-common-go/txDataBuilder"
	"github.com/multiversx/mx-chain-vm-go/testcommon"
	test "github.com/multiversx/mx-chain-vm-go/testcommon"
	"github.com/multiversx/mx-chain-vm-go/vmhost"
	"github.com/multiversx/mx-chain-vm-go/vmhost/contexts"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

/*
	TODO - for second release of async, some of the tests here that start from the same base graph
	will be automaticaly generated by a comprehensive (not fuzzy-ing) test generation component
*/

/*
	To enable graph SVG generation when tests run, change in testCallGraphUtils.go
		const generateGraphs = true
		const graphsFolder = "/home/bogdan/graphs/"
*/

var logAsync = logger.GetOrCreate("vm/async")

func TestGraph_SyncCalls_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestSyncCalls())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_SyncCalls2_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestSyncCalls2())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_SyncCalls_FailPropagation_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestSyncCallsFailPropagation())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_OneAsyncCall_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestOneAsyncCall())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_OneAsyncCallCustomGasLocked_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestOneAsyncCallCustomGasLocked())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_OneAsyncCallNoCallback_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestOneAsyncCallNoCallback())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_OneAsyncCallFail_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestOneAsyncCallFail())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_OneAsyncCallNoCallbackFail_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestOneAsyncCallNoCallbackFail())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallIndirectFail_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallIndirectFail())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_OneAsyncCallbackFail_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestOneAsyncCallbackFail())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallbackIndirectFail_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallbackIndirectFail())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_OneAsyncCallCrossShard_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestOneAsyncCallCrossShard())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_OneAsyncCallNoCallbackCrossShard_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestOneAsyncCallNoCallbackCrossShard())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_OneAsyncCallCrossShard2_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestOneAsyncCallCrossShard2())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_OneAsyncCallFailCrossShard_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestOneAsyncCallFailCrossShard())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_OneAsyncCallFailNoCallbackCrossShard_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestOneAsyncCallFailNoCallbackCrossShard())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallIndirectFailCrossShard_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallIndirectFailCrossShard())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_OneAsyncCallbackFailCrossShard_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestOneAsyncCallbackFailCrossShard())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallbackIndirectFailCrossShard_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallbackIndirectFailCrossShard())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCalls_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCalls())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsFirstNoCallback_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsFirstNoCallback())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsSecondNoCallback_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsSecondNoCallback())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsFirstFail_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsFirstFail())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsSecondFail_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsSecondFail())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsBothFail_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsBothFail())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsFirstCallbackFail_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsFirstCallbackFail())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsSecondCallbackFail_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsSecondCallbackFail())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsBothCallbacksFail_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsBothCallbacksFail())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCalls_LocalCross_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsLocalCross())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsFirstNoCallback_LocalCross_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncFirstNoCallbackCallsLocalCross())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsSecondNoCallback_LocalCross_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncSecondNoCallbackCallsLocalCross())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsFirstFail_LocalCross_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsFirstFailLocalCross())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsSecondFail_LocalCross_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsSecondFailLocalCross())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsBothFail_LocalCross_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsBothFailLocalCross())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsFirstCallbackFail_LocalCross_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsFirstCallbackFailLocalCross())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsSecondCallbackFail_LocalCross_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsSecondCallbackFailLocalCross())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsBothCallbacksFail_LocalCross_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsBothCallbacksFailLocalCross())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCalls_CrossLocal_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsCrossLocal())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsFirstNoCallback_CrossLocal_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsFirstNoCallbackCrossLocal())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsSecondNoCallback_CrossLocal_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsSecondNoCallbackCrossLocal())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsFirstFail_CrossLocal_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsFirstFailCrossLocal())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsSecondFail_CrossLocal_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsSecondFailCrossLocal())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsBothFail_CrossLocal_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsBothFailCrossLocal())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsFirstCallbackFail_CrossLocal_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsFirstCallbackFailCrossLocal())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsSecondCallbackFail_CrossLocal_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsSecondCallbackFailCrossLocal())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsBothCallbacksFail_CrossLocal_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsBothCallbacksFailCrossLocal())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsCrossShard_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsCrossShard())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsFirstNoCallback_CrossShard_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsFirstNoCallbackCrossShard())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsSecondNoCallback_CrossShard_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsSecondNoCallbackCrossShard())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsFirstFailCrossShard_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsFirstFailCrossShard())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsSecondFailCrossShard_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsSecondFailCrossShard())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsBothFailCrossShard_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsBothFailCrossShard())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsFirstCallbackFailCrossShard_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsFirstCallbackFailCrossShard())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsSecondCallbackFailCrossShard_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsSecondCallbackFailCrossShard())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_TwoAsyncCallsBothCallbacksFailCrossShard_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestTwoAsyncCallsBothCallbacksFailCrossShard())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncsOnMultiLevelFail1_CallGraph(t *testing.T) {
	// TODO remove test for R2
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsync())
	runGraphCallTestTemplateWithCustomAssertsConfig(t, callGraph, &assertsConfig{
		assertsAfterEachRootCall: noAssertsAfterEachRootCall,
		finalAsserts: func(t *testing.T, world *worldmock.MockWorld, expectedCallFinishData []*test.CallFinishDataItem, callsFinishData *test.CallsFinishData) {
			checkThatStoreIsEmpty(t, world)
			require.Equal(t, testcommon.ErrAsyncRegisterFail, callsFinishData.Data[1].FailError)
		},
	})
}

func TestGraph_AsyncsOnMultiLevelFail2_CallGraph(t *testing.T) {
	// TODO remove test for R2
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestSyncAndAsync5())
	runGraphCallTestTemplateWithCustomAssertsConfig(t, callGraph, &assertsConfig{
		assertsAfterEachRootCall: noAssertsAfterEachRootCall,
		finalAsserts: func(t *testing.T, world *worldmock.MockWorld, expectedCallFinishData []*test.CallFinishDataItem, callsFinishData *test.CallsFinishData) {
			checkThatStoreIsEmpty(t, world)
			require.Equal(t, testcommon.ErrAsyncRegisterFail, callsFinishData.Data[1].FailError)
		},
	})
}

func TestGraph_AsyncCallsAsync_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsync())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallsAsyncFirstNoCallback_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncFirstNoCallback())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallsAsyncSecondNoCallback_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncSecondNoCallback())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallsAsyncFirstFail_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncFirstFail())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallsAsyncFirstCallbackFail_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncFirstCallbackFail())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallsAsyncSecondFail_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncSecondFail())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallsAsyncSecondCallbackFail_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncSecondCallbackFail())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallsAsyncBothCallbacksFail_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncBothCallbacksFail())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallsAsync_CrossLocal_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncCrossLocal())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallsAsyncFirstNoCallback_CrossLocal_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncFirstNoCallbackCrossLocal())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallsAsyncSecondNoCallback_CrossLocal_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncSecondNoCallbackCrossLocal())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallsAsyncFirstFail_CrossLocal_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncFirstFailCrossLocal())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallsAsyncSecondFail_CrossLocal_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncSecondFailCrossLocal())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallsAsyncFirstCallbackFail_CrossLocal_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncFirstCallbackFailCrossLocal())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallsAsyncSecondCallbackFail_CrossLocal_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncSecondCallbackFailCrossLocal())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallsAsyncBothCallbacksFail_CrossLocal_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncBothCallbacksFailCrossLocal())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallsAsync_LocalCross_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncLocalCross())
	// TODO this is temp until R2
	runGraphCallTestTemplateWithCustomAssertsConfig(t, callGraph, assertsConfigForR1MultiLevel)
}

func TestGraph_AsyncCallsAsyncFirstNoCallback_LocalCross_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncFirstNoCallbackLocalCross())
	// TODO this is temp until R2
	runGraphCallTestTemplateWithCustomAssertsConfig(t, callGraph, assertsConfigForR1MultiLevel)
}

func TestGraph_AsyncCallsAsyncSecondNoCallback_LocalCross_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncSecondNoCallbackLocalCross())
	// TODO this is temp until R2
	runGraphCallTestTemplateWithCustomAssertsConfig(t, callGraph, assertsConfigForR1MultiLevel)
}

func TestGraph_AsyncCallsAsyncFirstFail_LocalCross_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncFirstFailLocalCross())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallsAsyncSecondFail_LocalCross_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncSecondFailLocalCross())
	// TODO this is temp until R2
	runGraphCallTestTemplateWithCustomAssertsConfig(t, callGraph, assertsConfigForR1MultiLevel)
}

func TestGraph_AsyncCallsAsyncFirstCallbackFail_LocalCross_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncFirstCallbackFailLocalCross())
	// TODO this is temp until R2
	runGraphCallTestTemplateWithCustomAssertsConfig(t, callGraph, assertsConfigForR1MultiLevel)
}

func TestGraph_AsyncCallsAsyncSecondCallbackFail_LocalCross_CallGraph(t *testing.T) {
	// TODO matei-p activate in R2 - this fails in R1 due gas usage missmatch error that
	// prevents storage cleanup taking place
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncSecondCallbackFailLocalCross())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallsAsyncBothCallbacksFail_LocalCross_CallGraph(t *testing.T) {
	// TODO matei-p activate in R2 - this fails in R1 due gas usage missmatch error that
	// prevents storage cleanup taking place
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncBothCallbacksFailLocalCross())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallsAsyncCrossShard_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncCrossShard())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallsAsyncFirstNoCallbackCrossShard_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncFirstNoCallbackCrossShard())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallsAsyncSecondNoCallbackCrossShard_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncSecondNoCallbackCrossShard())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallsAsyncFirstFailCrossShard_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncFirstFailCrossShard())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallsAsyncSecondFailCrossShard_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncSecondFailCrossShard())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallsAsyncFirstCallbackFailCrossShard_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncFirstCallbackFailCrossShard())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallsAsyncSecondCallbackFailCrossShard_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncSecondCallbackFailCrossShard())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCallsAsyncBothCallbacksFailCrossShard_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsAsyncBothCallbacksFailCrossShard())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_DifferentTypeOfCallsToSameFunction_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestDifferentTypeOfCallsToSameFunction())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_SameContractWithDifferentSubCalls_LocalLocal_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestSameContractWithDifferentSubCallsLocalLocal())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_SameContractWithDifferentSubCalls_LocalCross_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestSameContractWithDifferentSubCallsLocalCross())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_SameContractWithDifferentSubCalls_CrossLocal_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestSameContractWithDifferentSubCallsCrossLocal())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_SameContractWithDifferentSubCalls_CrossCross_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestSameContractWithDifferentSubCallsCrossCross())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_CallbackCallsSync_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestCallbackCallsSync())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_CallbackCallsAsync_LocalLocal_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestCallbackCallsAsyncLocalLocal())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_CallbackCallsAsyncFail_LocalLocal_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestCallbackCallsAsyncFailLocalLocal())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_CallbackCallsAsyncCallbackFail_LocalLocal_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestCallbackCallsAsyncCallbackFailLocalLocal())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_CallbackCallsAsync_LocalCross_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestCallbackCallsAsyncLocalCross())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_CallbackCallsAsyncFail_LocalCross_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestCallbackCallsAsyncFailLocalCross())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_CallbackCallsAsyncCallbackFail_LocalCross_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestCallbackCallsAsyncCallbackFailLocalCross())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_CallbackCallsAsync_CrossLocal_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestCallbackCallsAsyncCrossLocal())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_CallbackCallsAsyncFail_CrossLocal_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestCallbackCallsAsyncFailCrossLocal())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_CallbackCallsAsyncCallbackFail_CrossLocal_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestCallbackCallsAsyncCallbackFailCrossLocal())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_CallbackCallsAsync_CrossCross_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestCallbackCallsAsyncCrossCross())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_CallbackCallsAsyncFail_CrossCross_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestCallbackCallsAsyncFailCrossCross())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_CallbackCallsAsyncCallbackFail_CrossCross_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestCallbackCallsAsyncCallbackFailCrossCross())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_SyncAndAsync1_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestSyncAndAsync1())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_SyncAndAsync2_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestSyncAndAsync2())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_SyncAndAsync3_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestSyncAndAsync3())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_SyncAndAsync4_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestSyncAndAsync4())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_SyncAndAsync5_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestSyncAndAsync5())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_SyncAndAsync6_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestSyncAndAsync6())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_SyncAndAsync7_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestSyncAndAsync7())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_SyncAndAsync8_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestSyncAndAsync8())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_SyncAndAsync9_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestSyncAndAsync9())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_SyncAndAsync10_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestSyncAndAsync10())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_SyncAndAsync11_CallGraph(t *testing.T) {
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestSyncAndAsync11())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCall2_CrossShard_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsCrossShard2())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCall3_CrossShard_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsCrossShard3())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCall4_CrossShard_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsCrossShard4())
	// TODO this is temp until R2
	runGraphCallTestTemplateWithCustomAssertsConfig(t, callGraph, assertsConfigForR1MultiLevel)
}

func TestGraph_AsyncCall5_CrossShard_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsCrossShard5())
	// TODO this is temp until R2
	runGraphCallTestTemplateWithCustomAssertsConfig(t, callGraph, assertsConfigForR1MultiLevel)
}

func TestGraph_AsyncCall6_CrossShard_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsCrossShard6())
	// TODO this is temp until R2
	runGraphCallTestTemplateWithCustomAssertsConfig(t, callGraph, assertsConfigForR1MultiLevel)
}

func TestGraph_AsyncCall7_CrossShard_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsCrossShard7())
	RunGraphCallTestTemplate(t, callGraph)
}

func TestGraph_AsyncCall8_CrossShard_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsCrossShard8())
	// TODO this is temp until R2
	runGraphCallTestTemplateWithCustomAssertsConfig(t, callGraph, assertsConfigForR1MultiLevel)
}

func TestGraph_AsyncCall9_CrossShard_CallGraph(t *testing.T) {
	t.Skip("multi-level only")
	callGraph := test.MakeGraphAndImage(test.CreateGraphTestAsyncCallsCrossShard9())
	// TODO this is temp until R2
	runGraphCallTestTemplateWithCustomAssertsConfig(t, callGraph, assertsConfigForR1MultiLevel)
}

type assertsConfig struct {
	assertsAfterEachRootCall func(*test.TestCallNode, *worldmock.MockWorld, *test.VMOutputVerifier, []string)
	finalAsserts             func(t *testing.T, world *worldmock.MockWorld, expectedCallFinishData []*test.CallFinishDataItem, callsFinishData *test.CallsFinishData)
}

var noAssertsAfterEachRootCall = func(*test.TestCallNode, *worldmock.MockWorld, *test.VMOutputVerifier, []string) {}

//nolint:all
var assertsConfigForR1MultiLevel = &assertsConfig{
	assertsAfterEachRootCall: noAssertsAfterEachRootCall,
	finalAsserts: func(t *testing.T, world *worldmock.MockWorld, expectedCallFinishData []*test.CallFinishDataItem, callsFinishData *test.CallsFinishData) {
		checkCallFinishDataForGraphTesting(t, expectedCallFinishData, callsFinishData.Data)
	},
}

func RunGraphCallTestTemplate(t *testing.T, callGraph *test.TestCallGraph) {
	// regular tests, with full asserts
	runGraphCallTestTemplateWithCustomAssertsConfig(t, callGraph, &assertsConfig{
		assertsAfterEachRootCall: func(startNode *test.TestCallNode, world *worldmock.MockWorld, verify *test.VMOutputVerifier, expectedErrorsForRound []string) {
			if startNode.ErrFail == nil {
				verify.Ok().
					HasRuntimeErrors(expectedErrorsForRound...)
				// TODO matei-p will be implemented in R2
				// GasRemaining(callGraph.StartNode.GasLimit - totalGasUsed)
			} else {
				verify.ReturnCode(vmcommon.ExecutionFailed).
					GasRemaining(0).
					HasRuntimeErrors(expectedErrorsForRound...)
			}
		},
		finalAsserts: func(t *testing.T, world *worldmock.MockWorld, expectedCallFinishData []*test.CallFinishDataItem, callsFinishData *test.CallsFinishData) {
			checkThatStoreIsEmpty(t, world)
			checkCallFinishDataForGraphTesting(t, expectedCallFinishData, callsFinishData.Data)
		},
	})
}

func runGraphCallTestTemplateWithCustomAssertsConfig(t *testing.T, callGraph *test.TestCallGraph, assertsConfig *assertsConfig) {
	testConfig := makeTestConfig()
	testConfig.GasProvided = callGraph.StartNode.GasLimit
	testConfig.GasLockCost = test.DefaultCallGraphLockedGas

	executionGraph := callGraph.CreateExecutionGraphFromCallGraph()

	gasGraph := executionGraph.ComputeGasGraphFromExecutionGraph()
	gasGraph.PropagateSyncFailures()
	gasGraph.AssignExecutionRounds(t)
	gasGraph.ComputeRemainingGasBeforeCallbacks(t)
	gasGraph.ComputeRemainingGasAfterCallbacks()

	startNode := gasGraph.GetStartNode()
	crossShardCallsQueue := test.NewCrossShardCallQueue()
	crossShardCallsQueue.Enqueue(test.UserAddress, startNode, vm.DirectCall, []byte{}, []byte{})

	computeCallIDs(gasGraph)

	// compute execution order (return data) assertions and compute gas assertions
	expectedCallFinishData := computeExpectedValues(gasGraph)

	// graph gas sanity check
	totalGasUsed, totalGasRemaining := computeExpectedTotalGasValues(gasGraph)
	require.Equal(t, int(gasGraph.StartNode.GasLimit), int(totalGasUsed+totalGasRemaining), "Expected Gas Sanity Check")

	crtTxNumber := 0

	var currentVMOutput *vmcommon.VMOutput

	runtimeConfigsForCalls := make(map[string]*test.RuntimeConfigOfCall)
	callsFinishData := &test.CallsFinishData{
		Data: make([]*test.CallFinishDataItem, 0),
	}

	world := worldmock.NewMockWorld()

	// create contracts
	mockInstancesTestTemplate := test.BuildMockInstanceCallTest(t).
		WithContracts(
			test.CreateMockContractsFromAsyncTestCallGraph(callGraph, callsFinishData, runtimeConfigsForCalls, testConfig)...,
		)
	contractsInitialized := false

	var crossShardCall *test.CrossShardCall
	for !crossShardCallsQueue.IsEmpty() {
		crossShardCall = crossShardCallsQueue.Dequeue()
		startNode = crossShardCall.StartNode

		crtTxNumber++
		crtTxHash := big.NewInt(int64(crtTxNumber)).Bytes()
		crossShardCall.StartNode.CrtTxHash = crtTxHash

		expectedErrorsForRound := computeExpectedErrorsForRound(gasGraph, startNode)

		arguments := make([][]byte, 0)
		if len(crossShardCall.Data) != 0 {
			_, parsedArguments, err := parsers.NewCallArgsParser().ParseData(string(crossShardCall.Data))
			if err != nil {
				panic(err)
			}
			arguments = parsedArguments
		}

		asyncArguments := createAsyncArgumentsFromAsyncData(
			crossShardCall.AsyncData,
			crossShardCall.CallType,
			parsers.NewCallArgsParser().ParseArguments,
		)

		currentVMOutput, _ = mockInstancesTestTemplate.
			WithInput(test.CreateTestContractCallInputBuilder().
				WithCallerAddr(crossShardCall.CallerAddress).
				WithRecipientAddr(startNode.Call.ContractAddress).
				WithFunction(startNode.Call.FunctionName).
				WithGasProvided(startNode.GasLimit).
				WithGasLocked(startNode.GasLocked).
				WithCallType(crossShardCall.CallType).
				WithAsyncArguments(asyncArguments).
				WithArguments(arguments...).
				WithPrevTxHash(big.NewInt(int64(crtTxNumber-1)).Bytes()).
				WithCurrentTxHash(crtTxHash).
				Build()).
			WithSetup(func(host vmhost.VMHost, world *worldmock.MockWorld) {
				world.SelfShardID = world.GetShardOfAddress(startNode.Call.ContractAddress)
				setZeroCodeCosts(host)
				setAsyncCosts(host, testConfig.GasLockCost)
			}).
			AndAssertResultsWithWorld(world, !contractsInitialized, startNode, expectedErrorsForRound,
				assertsConfig.assertsAfterEachRootCall)
		contractsInitialized = true

		extractAndPersistStores(t, world, currentVMOutput)

		crossShardEdges := getCrossShardEdgesFromSubtree(gasGraph, startNode, crossShardCallsQueue)
		var callbackCallerID []byte
		if crossShardCall.CallType == vm.AsynchronousCall {
			argParser := parsers.NewCallArgsParser()
			parsedAsync, _ := argParser.ParseArguments(string(crossShardCall.AsyncData))
			callbackCallerID = parsedAsync[2]
		}
		extractOuptutTransferCalls(currentVMOutput, crossShardEdges, crossShardCallsQueue, callbackCallerID)
	}

	if assertsConfig.finalAsserts != nil {
		assertsConfig.finalAsserts(t, world, expectedCallFinishData, callsFinishData)
	}
}

func createAsyncArgumentsFromAsyncData(
	asyncData []byte,
	callType vm.CallType,
	parseArgumentsFunc func(data string) ([][]byte, error),
) *vmcommon.AsyncArguments {
	if callType == vm.DirectCall {
		return nil
	}
	// produces an empty frist argument
	parsedArgs, err := parseArgumentsFunc(string(asyncData))
	if err != nil && len(parsedArgs) < 3 {
		return nil
	}
	asyncArguments := &vmcommon.AsyncArguments{
		CallID:       parsedArgs[1],
		CallerCallID: parsedArgs[2],
	}
	if callType == vm.AsynchronousCallBack {
		asyncArguments.CallbackAsyncInitiatorCallID = parsedArgs[3]
		asyncArguments.GasAccumulated = uint64(big.NewInt(0).SetBytes(parsedArgs[4]).Int64())
	}
	return asyncArguments
}

func computeExpectedErrorsForRound(gasGraph *test.TestCallGraph, startNode *test.TestCallNode) []string {
	visits := make(map[uint]bool)
	expectedErrorsForRound := make([]string, 0)
	gasGraph.DfsGraphFromNode(startNode, func(path []*test.TestCallNode, parent *test.TestCallNode, node *test.TestCallNode, incomingEdge *test.TestCallEdge) *test.TestCallNode {
		if node.ExecutionRound != startNode.ExecutionRound {
			return node
		}
		edge := node.IncomingEdge
		if edge != nil && edge.CallbackFail == true {
			// for cross shard callbacks will detect error in their execution round
			return node
		}
		if edge != nil && edge.ErrFail != nil {
			expectedErrorsForRound = append(expectedErrorsForRound, edge.ErrFail.Error())
		}
		return node
	}, visits, false /* don't followCrossShardEdges */)
	return expectedErrorsForRound
}

func checkThatStoreIsEmpty(t testing.TB, world *worldmock.MockWorld) {
	for address, account := range world.AcctMap {
		for key, value := range account.Storage {
			require.Equal(t, []byte{}, value, fmt.Sprintf("Value present in storage for address '%s' key '%s'", address, key))
		}
	}
}

func getCrossShardEdgesFromSubtree(gasGraph *test.TestCallGraph, startNode *test.TestCallNode, _ *test.CrossShardCallsQueue) []*test.TestCallEdge {
	crossShardEdges := make([]*test.TestCallEdge, 0)
	visits := make(map[uint]bool)
	gasGraph.DfsGraphFromNode(startNode, func(path []*test.TestCallNode, parent *test.TestCallNode, node *test.TestCallNode, incomingEdge *test.TestCallEdge) *test.TestCallNode {
		for _, edge := range node.AdjacentEdges {
			if edge.Type == test.AsyncCrossShard || edge.Type == test.CallbackCrossShard {
				crossShardEdges = append(crossShardEdges, edge)
			}
		}
		return node
	}, visits, false /* don't followCrossShardEdges */)

	// if a parent context async exists, add it's callback edge also
	incomingEdgeType := startNode.GetIncomingEdgeType()
	if incomingEdgeType == test.CallbackCrossShard &&
		startNode.Parent != nil && startNode.Parent.Parent != nil {
		prevPrevNode := startNode.Parent.Parent
		if prevPrevNode.IsAsync() {
			for _, edge := range prevPrevNode.AdjacentEdges {
				if edge.Type == test.Callback || edge.Type == test.CallbackCrossShard {
					crossShardEdges = append(crossShardEdges, edge)
				}
			}
		}
	}

	return crossShardEdges
}

func executionOrderTraversal(gasGraph *test.TestCallGraph, nodeProcessing func(node *test.TestCallNode)) {
	sortedNodes := make(NodesList, 0)
	for _, node := range gasGraph.Nodes {
		if node.WillNotExecute() {
			continue
		}
		sortedNodes = append(sortedNodes, node)
	}
	sort.Stable(sortedNodes)

	for _, node := range sortedNodes {
		nodeProcessing(node)
	}
}

type NodesList []*test.TestCallNode

func (nodes NodesList) Len() int           { return len(nodes) }
func (nodes NodesList) Less(i, j int) bool { return nodes[i].ExecutionRound < nodes[j].ExecutionRound }
func (nodes NodesList) Swap(i, j int)      { nodes[i], nodes[j] = nodes[j], nodes[i] }

func computeCallIDs(gasGraph *test.TestCallGraph) {
	executionOrderTraversal(gasGraph, func(node *test.TestCallNode) {
		if node.IsLeaf() || node.Parent == nil {
			return
		}

		var parent *test.TestCallNode
		if node.GetIncomingEdgeType() == test.Callback {
			parent = node.Parent.Parent
		} else {
			parent = node.Parent
		}

		if parent != nil {
			parent.NonGasEdgeCounter++
			newCallID := append(parent.Call.CallID, big.NewInt(parent.NonGasEdgeCounter).Bytes()...)
			newCallID, _ = gasGraph.Crypto.Sha256(newCallID)
			node.Call.CallID = newCallID
		}
	})

}

func computeExpectedValues(gasGraph *test.TestCallGraph) []*test.CallFinishDataItem {
	expectedCallsFinishData := make([]*test.CallFinishDataItem, 0)

	executionOrderTraversal(gasGraph, func(node *test.TestCallNode) {
		parent := node.Parent
		if !node.IsLeaf() {
			return
		}

		if parent.Call.FunctionName == test.FakeCallbackName {
			return
		}

		expectedCallFinishData := &test.CallFinishDataItem{
			OriginalCallerAddr:  test.UserAddress,
			ContractAndFunction: string(parent.Call.ContractAddress) + "_" + parent.Call.FunctionName + test.TestReturnDataSuffix,
			GasProvided:         parent.GasLimit,
			GasRemaining:        parent.GasRemaining,
			FailError:           parent.ErrFail,
		}

		expectedCallsFinishData = append(expectedCallsFinishData, expectedCallFinishData)
	})

	return expectedCallsFinishData
}

func computeExpectedTotalGasValues(graph *test.TestCallGraph) (uint64, uint64) {
	visits := make(map[uint]bool)
	totalGasUsed := uint64(0)
	totalGasRemaining := uint64(0)

	graph.DfsFromNodeUntilFailures(graph.StartNode.Parent, graph.StartNode, nil, make([]*test.TestCallNode, 0),
		func(path []*test.TestCallNode, parent *test.TestCallNode, node *test.TestCallNode, incomingEdge *test.TestCallEdge) *test.TestCallNode {
			if node.IsLeaf() {
				// fmt.Printf("node %s used %d\n", node.VisualLabel, node.GasUsed)
				totalGasUsed += node.GasUsed
				return node
			}

			// all gas is used for failed calls
			if (parent == nil && node.HasFailSyncEdge()) ||
				node.IsIncomingEdgeFail() {
				// fmt.Printf("failed %s used %d\n", node.VisualLabel, node.GasLimit)
				totalGasUsed += node.GasLimit
				return node
			}

			if parent == nil {
				totalGasRemaining += node.GasRemaining + node.GasAccumulated
			} else if node.IsCallback() || (node.IsAsync() && !node.HasCallback()) {
				totalGasRemaining += node.GasAccumulated
			}

			return node
		}, visits)

	return totalGasUsed, totalGasRemaining
}

func extractOuptutTransferCalls(vmOutput *vmcommon.VMOutput, crossShardEdges []*test.TestCallEdge, crossShardCallsQueue *test.CrossShardCallsQueue, callbackCallerID []byte) {
	for _, crossShardEdge := range crossShardEdges {
		edgeToAddress := string(crossShardEdge.To.Call.ContractAddress)
		if crossShardEdge.Type == testcommon.CallbackCrossShard {
			asyncData := txDataBuilder.NewBuilder()
			asyncData.Func("")
			asyncData.Bytes(crossShardEdge.To.Call.CallID)
			asyncData.Bytes(crossShardEdge.To.Parent.Call.CallID)
			asyncData.Bytes(callbackCallerID)
			asyncData.Bytes(big.NewInt(0).Bytes())

			callData := txDataBuilder.NewBuilder()
			// This is just a placeholder, necessary not to break decoding, it's not used anywhere.
			callData.Func("<callback>")
			returnCode := vmOutput.ReturnCode
			callData.Bytes(contexts.ReturnCodeToBytes(returnCode))
			if returnCode == vmcommon.Ok {
				for _, data := range vmOutput.ReturnData {
					callData.Bytes(data)
				}
			} else {
				callData.Str(vmOutput.ReturnMessage)
			}

			encodedArgs := callData.ToBytes()
			crossShardCallsQueue.Enqueue(crossShardEdge.To.Parent.Call.ContractAddress, crossShardEdge.To,
				vm.AsynchronousCallBack, asyncData.ToBytes(), encodedArgs)

			return
		}
		for _, outputAccount := range vmOutput.OutputAccounts {
			transferDestinationAddress := string(outputAccount.Address)
			if edgeToAddress != transferDestinationAddress {
				continue
			}
			for _, outputTransfer := range outputAccount.OutputTransfers {
				callType := outputTransfer.CallType

				argParser := parsers.NewCallArgsParser()
				function, parsedArgs, _ := argParser.ParseData(string(outputTransfer.Data))

				parsedAsync, _ := argParser.ParseArguments(string(outputTransfer.AsyncData))
				callID := parsedAsync[1]

				var encodedArgs []byte
				if bytes.Equal(callID, crossShardEdge.To.Call.CallID) {
					logAsync.Trace("Found transfer",
						"sender", string(outputTransfer.SenderAddress),
						"to", string(outputAccount.Address),
						"gas limit", outputTransfer.GasLimit,
						"callType", callType,
						"data", contexts.DebugCallIDAsString(outputTransfer.Data))
					if callType == vm.AsynchronousCall {
						encodedArgs = outputTransfer.Data
					} else if callType == vm.AsynchronousCallBack {
						callData := txDataBuilder.NewBuilder()
						callData.Func(function)
						for _, arg := range parsedArgs {
							callData.Bytes(arg)
						}
						encodedArgs = callData.ToBytes()
					}
					crossShardCallsQueue.Enqueue(outputTransfer.SenderAddress, crossShardEdge.To,
						callType, outputTransfer.AsyncData, encodedArgs)
				}
			}
		}
	}
}

func extractAndPersistStores(tb testing.TB, world *worldmock.MockWorld, vmOutput *vmcommon.VMOutput) {
	// check if accounts with storage from OutputAccounts have the same shardID as world mock
	for _, outputAccount := range vmOutput.OutputAccounts {
		if len(outputAccount.StorageUpdates) != 0 {
			require.Equal(tb, world.SelfShardID, world.GetShardOfAddress(outputAccount.Address), fmt.Sprintf("Incorrect shard for account with address '%s'", string(outputAccount.Address)))
		}
	}

	err := world.UpdateAccounts(vmOutput.OutputAccounts, nil)
	assert.Nil(tb, err)
}

func checkCallFinishDataForGraphTesting(tb testing.TB, expectedCallsFinishData []*test.CallFinishDataItem, callsFinishData []*test.CallFinishDataItem) {
	require.Equal(tb, len(expectedCallsFinishData), len(callsFinishData), "CallFinishData length")
	for idx := range expectedCallsFinishData {
		expectedCallFinishData := expectedCallsFinishData[idx]
		actualCallFinishData := callsFinishData[idx]
		require.Equal(tb, expectedCallFinishData.OriginalCallerAddr, actualCallFinishData.OriginalCallerAddr, "OriginalCallerAddr - Call")
		require.Equal(tb, expectedCallFinishData.ContractAndFunction, actualCallFinishData.ContractAndFunction, "CallFinishData - Call")
		require.Equal(tb, int(expectedCallFinishData.GasProvided), int(actualCallFinishData.GasProvided), fmt.Sprintf("CallFinishData - Gas Limit for '%s'", actualCallFinishData.ContractAndFunction))
		require.Equal(tb, int(expectedCallFinishData.GasRemaining), int(actualCallFinishData.GasRemaining), fmt.Sprintf("CallFinishData - Gas Remaining for '%s'", actualCallFinishData.ContractAndFunction))
		require.Equal(tb, expectedCallFinishData.FailError, actualCallFinishData.FailError, fmt.Sprintf("CallFinishData - Fail error for '%s'", actualCallFinishData.ContractAndFunction))
	}
}
