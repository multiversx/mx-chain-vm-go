package vmhooksgenerate

import (
	"fmt"
)

// WriteRustWasmerImports autogenerate data in the provided file
func WriteRustWasmer5Imports(out *eiGenWriter, eiMetadata *EIMetadata) {
	autoGeneratedHeader(out)
	out.WriteString(`
#![allow(clippy::too_many_arguments)]

use multiversx_chain_vm_executor::VMHooksEarlyExit;
use wasmer::{imports, Function, FunctionEnv, FunctionEnvMut, Imports, Store};

use crate::we_vm_hooks::{convert_mem_length, convert_mem_ptr, with_vm_hooks, VMHooksWrapper};

`)

	for _, funcMetadata := range eiMetadata.AllFunctions {
		out.WriteString("#[rustfmt::skip]\n")
		out.WriteString(fmt.Sprintf(
			"fn %s%s",
			wasmerImportAdapterFunctionName(funcMetadata.Name),
			writeRustFnDeclarationArguments(
				"env: FunctionEnvMut<VMHooksWrapper>",
				funcMetadata,
				rustWasmerType,
				rustVMHooksReturnType,
			),
		))

		out.WriteString(" {\n")
		out.WriteString(fmt.Sprintf("    with_vm_hooks(env, |vh| vh.%s(", snakeCase(funcMetadata.Name)))

		for i, arg := range funcMetadata.Arguments {
			if i > 0 {
				out.WriteString(", ")
			}
			out.WriteString(rustWasmerExperimentalConvertArg(arg))
		}

		out.WriteString("))\n}\n\n")
	}

	out.WriteString(`pub fn generate_import_object(store: &mut Store, vh_wrapper: VMHooksWrapper) -> Imports {
    let function_env = FunctionEnv::new(store, vh_wrapper);

    imports! {
        "env" => {
`)

	for _, funcMetadata := range eiMetadata.AllFunctions {
		out.WriteString(fmt.Sprintf(
			"            \"%s\" => Function::new_typed_with_env(store, &function_env, %s),\n",
			lowerInitial(funcMetadata.Name),
			wasmerImportAdapterFunctionName(funcMetadata.Name),
		))
	}

	out.WriteString(`
        }
    }
}
`)

}
