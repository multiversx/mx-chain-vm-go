package vmhooksgenerate

import (
	"fmt"
)

func WriteRustVHDispatcherLegacy(out *eiGenWriter, eiMetadata *EIMetadata) {
	autoGeneratedHeader(out)
	out.WriteString(`
use std::ffi::c_void;

use multiversx_chain_vm_executor::{
    InstanceState, MemLength, MemPtr, VMHooks, VMHooksError,
};

use crate::host::vm_hooks::{TxContextVMHooksHandler, VMHooksDispatcher};

use super::WasmerProdInstanceState;

fn unwrap_or_set_breakpoint<R>(
    dispatcher: &mut VMHooksDispatcher<TxContextVMHooksHandler<WasmerProdInstanceState>>,
    result: Result<R, VMHooksError>,
) -> R
where
    R: Default,
{
    result.unwrap_or_else(|err| {
        let _ = dispatcher
            .handler
            .instance_state_ref
            .set_breakpoint_value(err);
        R::default()
    })
}

#[rustfmt::skip]
impl multiversx_chain_vm_executor::VMHooksLegacy for VMHooksDispatcher<TxContextVMHooksHandler<WasmerProdInstanceState>> {
    fn set_vm_hooks_ptr(&mut self, _vm_hooks_ptr: *mut c_void) {
    }
`)

	for _, funcMetadata := range eiMetadata.AllFunctions {
		out.WriteString(fmt.Sprintf(
			"\n    fn %s%s {\n",
			snakeCase(funcMetadata.Name),
			writeRustFnDeclarationArguments(
				"&mut self",
				funcMetadata,
				rustVMHooksType,
				rustVMHooksLegacyReturnType,
			),
		))

		out.WriteString(fmt.Sprintf(
			"        let result = VMHooks::%s(self",
			snakeCase(funcMetadata.Name),
		))

		for _, arg := range funcMetadata.Arguments {
			out.WriteString(", ")
			out.WriteString(snakeCase((arg.Name)))
		}

		out.WriteString(");\n")
		out.WriteString("        unwrap_or_set_breakpoint(self, result)\n")
		out.WriteString("    }\n")
	}

	out.WriteString(`}
`)
}
