package vmhooksgenerate

import (
	"bufio"
	"os"
	"strings"
)

// Local cost name from config/config.toml (might change in the future)
const localCostName = "localallocate"

// WriteRustWasmerMeteringHelpers generates code for wasmer_metering_helpers.rs
func WriteRustWasmerMeteringHelpers(out *eiGenWriter) {
	autoGeneratedHeader(out)
	out.WriteString("\nuse crate::executor_interface::OpcodeCost;\n")
	out.WriteString("use wasmer::wasmparser::Operator;\n\n")

	readFile, err := os.Open("generate/cmd/input/wasmer2_opcodes_short.txt")
	if err != nil {
		panic(err)
	}
	defer readFile.Close()

	fileScanner := bufio.NewScanner(readFile)
	fileScanner.Split(bufio.ScanLines)

	var content string
	for fileScanner.Scan() {
		line := fileScanner.Text()
		if strings.ToLower(line) == localCostName {
			// This operator doesn't really exist, so we skip it
			continue
		}
		content += "        Operator::" + line + " { .. } => " + "Some(opcode_cost.opcode_" + strings.ToLower(line) + "),\n"
	}

	writeFnGetLocalCost(out)
	writeFnGetOpcodeCost(out, content)
}

func writeFnGetLocalCost(out *eiGenWriter) {
	out.WriteString("pub fn get_local_cost(opcode_cost: &OpcodeCost) -> u32 {\n")
	out.WriteString("    opcode_cost.opcode_" + localCostName + "\n")
	out.WriteString("}\n\n")
}

func writeFnGetOpcodeCost(out *eiGenWriter, content string) {
	out.WriteString("pub fn get_opcode_cost(op: &Operator, opcode_cost: &OpcodeCost) -> Option<u32> {\n")
	out.WriteString("    match op {\n")
	out.WriteString(content)
	out.WriteString("        _ => None,\n")
	out.WriteString("    }\n")
	out.WriteString("}\n")
}
