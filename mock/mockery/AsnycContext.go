package mockery

import (
	vmcommon "github.com/multiversx/mx-chain-vm-common-go"
	mock "github.com/stretchr/testify/mock"

	vmhost "github.com/multiversx/mx-chain-vm-go/vmhost"
)

// MockAsyncContext is an autogenerated mock type for the AsyncContext type
type MockAsyncContext struct {
	mock.Mock
}

// ClearStateStack provides a mock function with no fields
func (_m *MockAsyncContext) ClearStateStack() {
	_m.Called()
}

// Clone provides a mock function with no fields
func (_m *MockAsyncContext) Clone() vmhost.AsyncContext {
	ret := _m.Called()

	if len(ret) == 0 {
		return _m
	}

	var r0 vmhost.AsyncContext
	if rf, ok := ret.Get(0).(func() vmhost.AsyncContext); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(vmhost.AsyncContext)
		}
	}

	return r0
}

// CompleteChildConditional provides a mock function with given fields: isChildComplete, callID, gasToAccumulate
func (_m *MockAsyncContext) CompleteChildConditional(isChildComplete bool, callID []byte, gasToAccumulate uint64) error {
	ret := _m.Called(isChildComplete, callID, gasToAccumulate)

	if len(ret) == 0 {
		return nil
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(bool, []byte, uint64) error); ok {
		r0 = rf(isChildComplete, callID, gasToAccumulate)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteFromCallID provides a mock function with given fields: address
func (_m *MockAsyncContext) DeleteFromCallID(address []byte) error {
	ret := _m.Called(address)

	if len(ret) == 0 {
		return nil
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte) error); ok {
		r0 = rf(address)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Execute provides a mock function with no fields
func (_m *MockAsyncContext) Execute() error {
	ret := _m.Called()

	if len(ret) == 0 {
		return nil
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ExecuteLocalCallbackAndFinishOutput provides a mock function with given fields: asyncCall, vmOutput, destinationCallInput, gasAccumulated, err
func (_m *MockAsyncContext) ExecuteLocalCallbackAndFinishOutput(asyncCall *vmhost.AsyncCall, vmOutput *vmcommon.VMOutput, gasAccumulated uint64, err error) (bool, *vmcommon.VMOutput) {
	ret := _m.Called(asyncCall, vmOutput, gasAccumulated, err)

	if len(ret) == 0 {
		return true, &vmcommon.VMOutput{}
	}

	var r0 bool
	var r1 *vmcommon.VMOutput
	if rf, ok := ret.Get(0).(func(*vmhost.AsyncCall, *vmcommon.VMOutput, uint64, error) (bool, *vmcommon.VMOutput)); ok {
		return rf(asyncCall, vmOutput, gasAccumulated, err)
	}
	if rf, ok := ret.Get(0).(func(*vmhost.AsyncCall, *vmcommon.VMOutput, uint64, error) bool); ok {
		r0 = rf(asyncCall, vmOutput, gasAccumulated, err)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(*vmhost.AsyncCall, *vmcommon.VMOutput, uint64, error) *vmcommon.VMOutput); ok {
		r1 = rf(asyncCall, vmOutput, gasAccumulated, err)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*vmcommon.VMOutput)
		}
	}

	return r0, r1
}

// GetAsyncCallByCallID provides a mock function with given fields: callID
func (_m *MockAsyncContext) GetAsyncCallByCallID(callID []byte) vmhost.AsyncCallLocation {
	ret := _m.Called(callID)

	if len(ret) == 0 {
		return nil
	}

	var r0 vmhost.AsyncCallLocation
	if rf, ok := ret.Get(0).(func([]byte) vmhost.AsyncCallLocation); ok {
		r0 = rf(callID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(vmhost.AsyncCallLocation)
		}
	}

	return r0
}

// GetCallGroup provides a mock function with given fields: groupID
func (_m *MockAsyncContext) GetCallGroup(groupID string) (*vmhost.AsyncCallGroup, bool) {
	ret := _m.Called(groupID)

	if len(ret) == 0 {
		return &vmhost.AsyncCallGroup{}, true
	}

	var r0 *vmhost.AsyncCallGroup
	var r1 bool
	if rf, ok := ret.Get(0).(func(string) (*vmhost.AsyncCallGroup, bool)); ok {
		return rf(groupID)
	}
	if rf, ok := ret.Get(0).(func(string) *vmhost.AsyncCallGroup); ok {
		r0 = rf(groupID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vmhost.AsyncCallGroup)
		}
	}

	if rf, ok := ret.Get(1).(func(string) bool); ok {
		r1 = rf(groupID)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GetCallID provides a mock function with no fields
func (_m *MockAsyncContext) GetCallID() []byte {
	ret := _m.Called()

	if len(ret) == 0 {
		return []byte("callID")
	}

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// GetCallbackAsyncInitiatorCallID provides a mock function with no fields
func (_m *MockAsyncContext) GetCallbackAsyncInitiatorCallID() []byte {
	ret := _m.Called()

	if len(ret) == 0 {
		return []byte("callID")
	}

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// GetCallbackClosure provides a mock function with no fields
func (_m *MockAsyncContext) GetCallbackClosure() ([]byte, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		return []byte("callID"), nil
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]byte, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCallerAddress provides a mock function with no fields
func (_m *MockAsyncContext) GetCallerAddress() []byte {
	ret := _m.Called()

	if len(ret) == 0 {
		return []byte("caller")
	}

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// GetCallerCallID provides a mock function with no fields
func (_m *MockAsyncContext) GetCallerCallID() []byte {
	ret := _m.Called()

	if len(ret) == 0 {
		return []byte("callID")
	}

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// GetGasAccumulated provides a mock function with no fields
func (_m *MockAsyncContext) GetGasAccumulated() uint64 {
	ret := _m.Called()

	if len(ret) == 0 {
		return 1
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// GetParentAddress provides a mock function with no fields
func (_m *MockAsyncContext) GetParentAddress() []byte {
	ret := _m.Called()

	if len(ret) == 0 {
		return []byte("parent")
	}

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// GetReturnData provides a mock function with no fields
func (_m *MockAsyncContext) GetReturnData() []byte {
	ret := _m.Called()

	if len(ret) == 0 {
		return []byte{}
	}

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// HasCallback provides a mock function with no fields
func (_m *MockAsyncContext) HasCallback() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		return true
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// HasLegacyGroup provides a mock function with no fields
func (_m *MockAsyncContext) HasLegacyGroup() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		return true
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// HasPendingCallGroups provides a mock function with no fields
func (_m *MockAsyncContext) HasPendingCallGroups() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		return false
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// InitState provides a mock function with no fields
func (_m *MockAsyncContext) InitState() {
	_m.Called()
}

// InitStateFromInput provides a mock function with given fields: input
func (_m *MockAsyncContext) InitStateFromInput(input *vmcommon.ContractCallInput) error {
	ret := _m.Called(input)

	if len(ret) == 0 {
		return nil
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*vmcommon.ContractCallInput) error); ok {
		r0 = rf(input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IsComplete provides a mock function with no fields
func (_m *MockAsyncContext) IsComplete() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		return true
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsCrossShard provides a mock function with no fields
func (_m *MockAsyncContext) IsCrossShard() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		return true
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// LoadParentContext provides a mock function with no fields
func (_m *MockAsyncContext) LoadParentContext() error {
	ret := _m.Called()

	if len(ret) == 0 {
		return nil
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LoadParentContextFromStackOrStorage provides a mock function with no fields
func (_m *MockAsyncContext) LoadParentContextFromStackOrStorage() (vmhost.AsyncContext, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		return _m, nil
	}

	var r0 vmhost.AsyncContext
	var r1 error
	if rf, ok := ret.Get(0).(func() (vmhost.AsyncContext, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() vmhost.AsyncContext); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(vmhost.AsyncContext)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NotifyChildIsComplete provides a mock function with given fields: callID, gasToAccumulate
func (_m *MockAsyncContext) NotifyChildIsComplete(callID []byte, gasToAccumulate uint64) error {
	ret := _m.Called(callID, gasToAccumulate)

	if len(ret) == 0 {
		return nil
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte, uint64) error); ok {
		r0 = rf(callID, gasToAccumulate)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PopDiscard provides a mock function with no fields
func (_m *MockAsyncContext) PopDiscard() {
	_m.Called()
}

// PopSetActiveState provides a mock function with no fields
func (_m *MockAsyncContext) PopSetActiveState() {
	_m.Called()
}

// PushState provides a mock function with no fields
func (_m *MockAsyncContext) PushState() {
	_m.Called()
}

// RegisterAsyncCall provides a mock function with given fields: groupID, call
func (_m *MockAsyncContext) RegisterAsyncCall(groupID string, call *vmhost.AsyncCall) error {
	ret := _m.Called(groupID, call)

	if len(ret) == 0 {
		return nil
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, *vmhost.AsyncCall) error); ok {
		r0 = rf(groupID, call)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RegisterLegacyAsyncCall provides a mock function with given fields: address, data, value
func (_m *MockAsyncContext) RegisterLegacyAsyncCall(address []byte, data []byte, value []byte) error {
	ret := _m.Called(address, data, value)

	if len(ret) == 0 {
		return nil
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte, []byte, []byte) error); ok {
		r0 = rf(address, data, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Save provides a mock function with no fields
func (_m *MockAsyncContext) Save() error {
	ret := _m.Called()

	if len(ret) == 0 {
		return nil
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetAsyncArgumentsForCall provides a mock function with given fields: input
func (_m *MockAsyncContext) SetAsyncArgumentsForCall(input *vmcommon.ContractCallInput) {
	_m.Called(input)
}

// SetAsyncArgumentsForCallback provides a mock function with given fields: input, asyncCall, gasAccumulated
func (_m *MockAsyncContext) SetAsyncArgumentsForCallback(input *vmcommon.ContractCallInput, asyncCall *vmhost.AsyncCall, gasAccumulated uint64) {
	_m.Called(input, asyncCall, gasAccumulated)
}

// SetCallID provides a mock function with given fields: callID
func (_m *MockAsyncContext) SetCallID(callID []byte) {
	_m.Called(callID)
}

// SetCallIDForCallInGroup provides a mock function with given fields: groupIndex, callIndex, callID
func (_m *MockAsyncContext) SetCallIDForCallInGroup(groupIndex int, callIndex int, callID []byte) {
	_m.Called(groupIndex, callIndex, callID)
}

// SetCallbackParentCall provides a mock function with given fields: asyncCall
func (_m *MockAsyncContext) SetCallbackParentCall(asyncCall *vmhost.AsyncCall) {
	_m.Called(asyncCall)
}

// SetContextCallback provides a mock function with given fields: callbackName, data, gas
func (_m *MockAsyncContext) SetContextCallback(callbackName string, data []byte, gas uint64) error {
	ret := _m.Called(callbackName, data, gas)

	if len(ret) == 0 {
		return nil
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, []byte, uint64) error); ok {
		r0 = rf(callbackName, data, gas)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetResults provides a mock function with given fields: vmOutput
func (_m *MockAsyncContext) SetResults(vmOutput *vmcommon.VMOutput) {
	_m.Called(vmOutput)
}

// SetReturnData provides a mock function with given fields: data
func (_m *MockAsyncContext) SetReturnData(data []byte) {
	_m.Called(data)
}

// UpdateCurrentAsyncCallStatus provides a mock function with given fields: address, callID, vmInput
func (_m *MockAsyncContext) UpdateCurrentAsyncCallStatus(address []byte, callID []byte, vmInput *vmcommon.VMInput) (*vmhost.AsyncCall, bool, error) {
	ret := _m.Called(address, callID, vmInput)

	if len(ret) == 0 {
		return &vmhost.AsyncCall{}, false, nil
	}

	var r0 *vmhost.AsyncCall
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func([]byte, []byte, *vmcommon.VMInput) (*vmhost.AsyncCall, bool, error)); ok {
		return rf(address, callID, vmInput)
	}
	if rf, ok := ret.Get(0).(func([]byte, []byte, *vmcommon.VMInput) *vmhost.AsyncCall); ok {
		r0 = rf(address, callID, vmInput)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vmhost.AsyncCall)
		}
	}

	if rf, ok := ret.Get(1).(func([]byte, []byte, *vmcommon.VMInput) bool); ok {
		r1 = rf(address, callID, vmInput)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func([]byte, []byte, *vmcommon.VMInput) error); ok {
		r2 = rf(address, callID, vmInput)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NewMockAsyncContext creates a new instance of MockAsyncContext. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAsyncContext(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAsyncContext {
	mock := &MockAsyncContext{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
