// Code generated by mockery v2.53.4. DO NOT EDIT.

package mockery

import (
	elliptic "crypto/elliptic"
	big "math/big"

	io "io"

	mock "github.com/stretchr/testify/mock"

	vmcommon "github.com/multiversx/mx-chain-vm-common-go"
)

// MockManagedTypesContext is an autogenerated mock type for the ManagedTypesContext type
type MockManagedTypesContext struct {
	mock.Mock
}

// AddBackTransfers provides a mock function with given fields: value, transfers, index
func (_m *MockManagedTypesContext) AddBackTransfers(value *big.Int, transfers []*vmcommon.ESDTTransfer, index uint32) {
	_m.Called(value, transfers, index)
}

// AppendBytes provides a mock function with given fields: mBufferHandle, bytes
func (_m *MockManagedTypesContext) AppendBytes(mBufferHandle int32, bytes []byte) bool {
	ret := _m.Called(mBufferHandle, bytes)

	if len(ret) == 0 {
		panic("no return value specified for AppendBytes")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(int32, []byte) bool); ok {
		r0 = rf(mBufferHandle, bytes)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// BigFloatExpIsNotValid provides a mock function with given fields: exponent
func (_m *MockManagedTypesContext) BigFloatExpIsNotValid(exponent int) bool {
	ret := _m.Called(exponent)

	if len(ret) == 0 {
		panic("no return value specified for BigFloatExpIsNotValid")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(int) bool); ok {
		r0 = rf(exponent)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// BigFloatPrecIsNotValid provides a mock function with given fields: precision
func (_m *MockManagedTypesContext) BigFloatPrecIsNotValid(precision uint) bool {
	ret := _m.Called(precision)

	if len(ret) == 0 {
		panic("no return value specified for BigFloatPrecIsNotValid")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(uint) bool); ok {
		r0 = rf(precision)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// ClearStateStack provides a mock function with no fields
func (_m *MockManagedTypesContext) ClearStateStack() {
	_m.Called()
}

// ConsumeGasForBigFloatCopy provides a mock function with given fields: values
func (_m *MockManagedTypesContext) ConsumeGasForBigFloatCopy(values ...*big.Float) error {
	_va := make([]interface{}, len(values))
	for _i := range values {
		_va[_i] = values[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ConsumeGasForBigFloatCopy")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(...*big.Float) error); ok {
		r0 = rf(values...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ConsumeGasForBigIntCopy provides a mock function with given fields: values
func (_m *MockManagedTypesContext) ConsumeGasForBigIntCopy(values ...*big.Int) error {
	_va := make([]interface{}, len(values))
	for _i := range values {
		_va[_i] = values[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ConsumeGasForBigIntCopy")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(...*big.Int) error); ok {
		r0 = rf(values...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ConsumeGasForBytes provides a mock function with given fields: bytes
func (_m *MockManagedTypesContext) ConsumeGasForBytes(bytes []byte) error {
	ret := _m.Called(bytes)

	if len(ret) == 0 {
		panic("no return value specified for ConsumeGasForBytes")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte) error); ok {
		r0 = rf(bytes)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ConsumeGasForThisBigIntNumberOfBytes provides a mock function with given fields: byteLen
func (_m *MockManagedTypesContext) ConsumeGasForThisBigIntNumberOfBytes(byteLen *big.Int) error {
	ret := _m.Called(byteLen)

	if len(ret) == 0 {
		panic("no return value specified for ConsumeGasForThisBigIntNumberOfBytes")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*big.Int) error); ok {
		r0 = rf(byteLen)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ConsumeGasForThisIntNumberOfBytes provides a mock function with given fields: byteLen
func (_m *MockManagedTypesContext) ConsumeGasForThisIntNumberOfBytes(byteLen int) error {
	ret := _m.Called(byteLen)

	if len(ret) == 0 {
		panic("no return value specified for ConsumeGasForThisIntNumberOfBytes")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int) error); ok {
		r0 = rf(byteLen)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteSlice provides a mock function with given fields: mBufferHandle, startPosition, lengthOfSlice
func (_m *MockManagedTypesContext) DeleteSlice(mBufferHandle int32, startPosition int32, lengthOfSlice int32) ([]byte, error) {
	ret := _m.Called(mBufferHandle, startPosition, lengthOfSlice)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSlice")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(int32, int32, int32) ([]byte, error)); ok {
		return rf(mBufferHandle, startPosition, lengthOfSlice)
	}
	if rf, ok := ret.Get(0).(func(int32, int32, int32) []byte); ok {
		r0 = rf(mBufferHandle, startPosition, lengthOfSlice)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(int32, int32, int32) error); ok {
		r1 = rf(mBufferHandle, startPosition, lengthOfSlice)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EncodedBigFloatIsNotValid provides a mock function with given fields: encodedBigFloat
func (_m *MockManagedTypesContext) EncodedBigFloatIsNotValid(encodedBigFloat []byte) bool {
	ret := _m.Called(encodedBigFloat)

	if len(ret) == 0 {
		panic("no return value specified for EncodedBigFloatIsNotValid")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func([]byte) bool); ok {
		r0 = rf(encodedBigFloat)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Get100xCurveGasCostMultiplier provides a mock function with given fields: ecHandle
func (_m *MockManagedTypesContext) Get100xCurveGasCostMultiplier(ecHandle int32) int32 {
	ret := _m.Called(ecHandle)

	if len(ret) == 0 {
		panic("no return value specified for Get100xCurveGasCostMultiplier")
	}

	var r0 int32
	if rf, ok := ret.Get(0).(func(int32) int32); ok {
		r0 = rf(ecHandle)
	} else {
		r0 = ret.Get(0).(int32)
	}

	return r0
}

// GetBackTransfers provides a mock function with no fields
func (_m *MockManagedTypesContext) GetBackTransfers() ([]*vmcommon.ESDTTransfer, *big.Int) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetBackTransfers")
	}

	var r0 []*vmcommon.ESDTTransfer
	var r1 *big.Int
	if rf, ok := ret.Get(0).(func() ([]*vmcommon.ESDTTransfer, *big.Int)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []*vmcommon.ESDTTransfer); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*vmcommon.ESDTTransfer)
		}
	}

	if rf, ok := ret.Get(1).(func() *big.Int); ok {
		r1 = rf()
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*big.Int)
		}
	}

	return r0, r1
}

// GetBigFloat provides a mock function with given fields: handle
func (_m *MockManagedTypesContext) GetBigFloat(handle int32) (*big.Float, error) {
	ret := _m.Called(handle)

	if len(ret) == 0 {
		panic("no return value specified for GetBigFloat")
	}

	var r0 *big.Float
	var r1 error
	if rf, ok := ret.Get(0).(func(int32) (*big.Float, error)); ok {
		return rf(handle)
	}
	if rf, ok := ret.Get(0).(func(int32) *big.Float); ok {
		r0 = rf(handle)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Float)
		}
	}

	if rf, ok := ret.Get(1).(func(int32) error); ok {
		r1 = rf(handle)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBigFloatOrCreate provides a mock function with given fields: handle
func (_m *MockManagedTypesContext) GetBigFloatOrCreate(handle int32) (*big.Float, error) {
	ret := _m.Called(handle)

	if len(ret) == 0 {
		panic("no return value specified for GetBigFloatOrCreate")
	}

	var r0 *big.Float
	var r1 error
	if rf, ok := ret.Get(0).(func(int32) (*big.Float, error)); ok {
		return rf(handle)
	}
	if rf, ok := ret.Get(0).(func(int32) *big.Float); ok {
		r0 = rf(handle)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Float)
		}
	}

	if rf, ok := ret.Get(1).(func(int32) error); ok {
		r1 = rf(handle)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBigInt provides a mock function with given fields: id
func (_m *MockManagedTypesContext) GetBigInt(id int32) (*big.Int, error) {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for GetBigInt")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(int32) (*big.Int, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(int32) *big.Int); ok {
		r0 = rf(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(int32) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBigIntOrCreate provides a mock function with given fields: handle
func (_m *MockManagedTypesContext) GetBigIntOrCreate(handle int32) *big.Int {
	ret := _m.Called(handle)

	if len(ret) == 0 {
		panic("no return value specified for GetBigIntOrCreate")
	}

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(int32) *big.Int); ok {
		r0 = rf(handle)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	return r0
}

// GetBytes provides a mock function with given fields: mBufferHandle
func (_m *MockManagedTypesContext) GetBytes(mBufferHandle int32) ([]byte, error) {
	ret := _m.Called(mBufferHandle)

	if len(ret) == 0 {
		panic("no return value specified for GetBytes")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(int32) ([]byte, error)); ok {
		return rf(mBufferHandle)
	}
	if rf, ok := ret.Get(0).(func(int32) []byte); ok {
		r0 = rf(mBufferHandle)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(int32) error); ok {
		r1 = rf(mBufferHandle)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEllipticCurve provides a mock function with given fields: handle
func (_m *MockManagedTypesContext) GetEllipticCurve(handle int32) (*elliptic.CurveParams, error) {
	ret := _m.Called(handle)

	if len(ret) == 0 {
		panic("no return value specified for GetEllipticCurve")
	}

	var r0 *elliptic.CurveParams
	var r1 error
	if rf, ok := ret.Get(0).(func(int32) (*elliptic.CurveParams, error)); ok {
		return rf(handle)
	}
	if rf, ok := ret.Get(0).(func(int32) *elliptic.CurveParams); ok {
		r0 = rf(handle)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elliptic.CurveParams)
		}
	}

	if rf, ok := ret.Get(1).(func(int32) error); ok {
		r1 = rf(handle)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEllipticCurveSizeOfField provides a mock function with given fields: ecHandle
func (_m *MockManagedTypesContext) GetEllipticCurveSizeOfField(ecHandle int32) int32 {
	ret := _m.Called(ecHandle)

	if len(ret) == 0 {
		panic("no return value specified for GetEllipticCurveSizeOfField")
	}

	var r0 int32
	if rf, ok := ret.Get(0).(func(int32) int32); ok {
		r0 = rf(ecHandle)
	} else {
		r0 = ret.Get(0).(int32)
	}

	return r0
}

// GetLength provides a mock function with given fields: mBufferHandle
func (_m *MockManagedTypesContext) GetLength(mBufferHandle int32) int32 {
	ret := _m.Called(mBufferHandle)

	if len(ret) == 0 {
		panic("no return value specified for GetLength")
	}

	var r0 int32
	if rf, ok := ret.Get(0).(func(int32) int32); ok {
		r0 = rf(mBufferHandle)
	} else {
		r0 = ret.Get(0).(int32)
	}

	return r0
}

// GetPrivateKeyByteLengthEC provides a mock function with given fields: ecHandle
func (_m *MockManagedTypesContext) GetPrivateKeyByteLengthEC(ecHandle int32) int32 {
	ret := _m.Called(ecHandle)

	if len(ret) == 0 {
		panic("no return value specified for GetPrivateKeyByteLengthEC")
	}

	var r0 int32
	if rf, ok := ret.Get(0).(func(int32) int32); ok {
		r0 = rf(ecHandle)
	} else {
		r0 = ret.Get(0).(int32)
	}

	return r0
}

// GetRandReader provides a mock function with no fields
func (_m *MockManagedTypesContext) GetRandReader() io.Reader {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetRandReader")
	}

	var r0 io.Reader
	if rf, ok := ret.Get(0).(func() io.Reader); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.Reader)
		}
	}

	return r0
}

// GetScalarMult100xCurveGasCostMultiplier provides a mock function with given fields: ecHandle
func (_m *MockManagedTypesContext) GetScalarMult100xCurveGasCostMultiplier(ecHandle int32) int32 {
	ret := _m.Called(ecHandle)

	if len(ret) == 0 {
		panic("no return value specified for GetScalarMult100xCurveGasCostMultiplier")
	}

	var r0 int32
	if rf, ok := ret.Get(0).(func(int32) int32); ok {
		r0 = rf(ecHandle)
	} else {
		r0 = ret.Get(0).(int32)
	}

	return r0
}

// GetSlice provides a mock function with given fields: mBufferHandle, startPosition, lengthOfSlice
func (_m *MockManagedTypesContext) GetSlice(mBufferHandle int32, startPosition int32, lengthOfSlice int32) ([]byte, error) {
	ret := _m.Called(mBufferHandle, startPosition, lengthOfSlice)

	if len(ret) == 0 {
		panic("no return value specified for GetSlice")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(int32, int32, int32) ([]byte, error)); ok {
		return rf(mBufferHandle, startPosition, lengthOfSlice)
	}
	if rf, ok := ret.Get(0).(func(int32, int32, int32) []byte); ok {
		r0 = rf(mBufferHandle, startPosition, lengthOfSlice)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(int32, int32, int32) error); ok {
		r1 = rf(mBufferHandle, startPosition, lengthOfSlice)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTwoBigFloats provides a mock function with given fields: handle1, handle2
func (_m *MockManagedTypesContext) GetTwoBigFloats(handle1 int32, handle2 int32) (*big.Float, *big.Float, error) {
	ret := _m.Called(handle1, handle2)

	if len(ret) == 0 {
		panic("no return value specified for GetTwoBigFloats")
	}

	var r0 *big.Float
	var r1 *big.Float
	var r2 error
	if rf, ok := ret.Get(0).(func(int32, int32) (*big.Float, *big.Float, error)); ok {
		return rf(handle1, handle2)
	}
	if rf, ok := ret.Get(0).(func(int32, int32) *big.Float); ok {
		r0 = rf(handle1, handle2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Float)
		}
	}

	if rf, ok := ret.Get(1).(func(int32, int32) *big.Float); ok {
		r1 = rf(handle1, handle2)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*big.Float)
		}
	}

	if rf, ok := ret.Get(2).(func(int32, int32) error); ok {
		r2 = rf(handle1, handle2)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetTwoBigInt provides a mock function with given fields: handle1, handle2
func (_m *MockManagedTypesContext) GetTwoBigInt(handle1 int32, handle2 int32) (*big.Int, *big.Int, error) {
	ret := _m.Called(handle1, handle2)

	if len(ret) == 0 {
		panic("no return value specified for GetTwoBigInt")
	}

	var r0 *big.Int
	var r1 *big.Int
	var r2 error
	if rf, ok := ret.Get(0).(func(int32, int32) (*big.Int, *big.Int, error)); ok {
		return rf(handle1, handle2)
	}
	if rf, ok := ret.Get(0).(func(int32, int32) *big.Int); ok {
		r0 = rf(handle1, handle2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(int32, int32) *big.Int); ok {
		r1 = rf(handle1, handle2)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*big.Int)
		}
	}

	if rf, ok := ret.Get(2).(func(int32, int32) error); ok {
		r2 = rf(handle1, handle2)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetUCompressed100xCurveGasCostMultiplier provides a mock function with given fields: ecHandle
func (_m *MockManagedTypesContext) GetUCompressed100xCurveGasCostMultiplier(ecHandle int32) int32 {
	ret := _m.Called(ecHandle)

	if len(ret) == 0 {
		panic("no return value specified for GetUCompressed100xCurveGasCostMultiplier")
	}

	var r0 int32
	if rf, ok := ret.Get(0).(func(int32) int32); ok {
		r0 = rf(ecHandle)
	} else {
		r0 = ret.Get(0).(int32)
	}

	return r0
}

// InitState provides a mock function with no fields
func (_m *MockManagedTypesContext) InitState() {
	_m.Called()
}

// InsertSlice provides a mock function with given fields: mBufferHandle, startPosition, slice
func (_m *MockManagedTypesContext) InsertSlice(mBufferHandle int32, startPosition int32, slice []byte) ([]byte, error) {
	ret := _m.Called(mBufferHandle, startPosition, slice)

	if len(ret) == 0 {
		panic("no return value specified for InsertSlice")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(int32, int32, []byte) ([]byte, error)); ok {
		return rf(mBufferHandle, startPosition, slice)
	}
	if rf, ok := ret.Get(0).(func(int32, int32, []byte) []byte); ok {
		r0 = rf(mBufferHandle, startPosition, slice)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(int32, int32, []byte) error); ok {
		r1 = rf(mBufferHandle, startPosition, slice)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManagedMapContains provides a mock function with given fields: mMapHandle, keyHandle
func (_m *MockManagedTypesContext) ManagedMapContains(mMapHandle int32, keyHandle int32) (bool, error) {
	ret := _m.Called(mMapHandle, keyHandle)

	if len(ret) == 0 {
		panic("no return value specified for ManagedMapContains")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(int32, int32) (bool, error)); ok {
		return rf(mMapHandle, keyHandle)
	}
	if rf, ok := ret.Get(0).(func(int32, int32) bool); ok {
		r0 = rf(mMapHandle, keyHandle)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(int32, int32) error); ok {
		r1 = rf(mMapHandle, keyHandle)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManagedMapGet provides a mock function with given fields: mMapHandle, keyHandle, outValueHandle
func (_m *MockManagedTypesContext) ManagedMapGet(mMapHandle int32, keyHandle int32, outValueHandle int32) error {
	ret := _m.Called(mMapHandle, keyHandle, outValueHandle)

	if len(ret) == 0 {
		panic("no return value specified for ManagedMapGet")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int32, int32, int32) error); ok {
		r0 = rf(mMapHandle, keyHandle, outValueHandle)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ManagedMapPut provides a mock function with given fields: mMapHandle, keyHandle, valueHandle
func (_m *MockManagedTypesContext) ManagedMapPut(mMapHandle int32, keyHandle int32, valueHandle int32) error {
	ret := _m.Called(mMapHandle, keyHandle, valueHandle)

	if len(ret) == 0 {
		panic("no return value specified for ManagedMapPut")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int32, int32, int32) error); ok {
		r0 = rf(mMapHandle, keyHandle, valueHandle)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ManagedMapRemove provides a mock function with given fields: mMapHandle, keyHandle, outValueHandle
func (_m *MockManagedTypesContext) ManagedMapRemove(mMapHandle int32, keyHandle int32, outValueHandle int32) error {
	ret := _m.Called(mMapHandle, keyHandle, outValueHandle)

	if len(ret) == 0 {
		panic("no return value specified for ManagedMapRemove")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int32, int32, int32) error); ok {
		r0 = rf(mMapHandle, keyHandle, outValueHandle)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewBigInt provides a mock function with given fields: value
func (_m *MockManagedTypesContext) NewBigInt(value *big.Int) int32 {
	ret := _m.Called(value)

	if len(ret) == 0 {
		panic("no return value specified for NewBigInt")
	}

	var r0 int32
	if rf, ok := ret.Get(0).(func(*big.Int) int32); ok {
		r0 = rf(value)
	} else {
		r0 = ret.Get(0).(int32)
	}

	return r0
}

// NewBigIntFromInt64 provides a mock function with given fields: int64Value
func (_m *MockManagedTypesContext) NewBigIntFromInt64(int64Value int64) int32 {
	ret := _m.Called(int64Value)

	if len(ret) == 0 {
		panic("no return value specified for NewBigIntFromInt64")
	}

	var r0 int32
	if rf, ok := ret.Get(0).(func(int64) int32); ok {
		r0 = rf(int64Value)
	} else {
		r0 = ret.Get(0).(int32)
	}

	return r0
}

// NewManagedBuffer provides a mock function with no fields
func (_m *MockManagedTypesContext) NewManagedBuffer() int32 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for NewManagedBuffer")
	}

	var r0 int32
	if rf, ok := ret.Get(0).(func() int32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int32)
	}

	return r0
}

// NewManagedBufferFromBytes provides a mock function with given fields: bytes
func (_m *MockManagedTypesContext) NewManagedBufferFromBytes(bytes []byte) int32 {
	ret := _m.Called(bytes)

	if len(ret) == 0 {
		panic("no return value specified for NewManagedBufferFromBytes")
	}

	var r0 int32
	if rf, ok := ret.Get(0).(func([]byte) int32); ok {
		r0 = rf(bytes)
	} else {
		r0 = ret.Get(0).(int32)
	}

	return r0
}

// NewManagedMap provides a mock function with no fields
func (_m *MockManagedTypesContext) NewManagedMap() int32 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for NewManagedMap")
	}

	var r0 int32
	if rf, ok := ret.Get(0).(func() int32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int32)
	}

	return r0
}

// PopBackTransferIfAsyncCallBack provides a mock function with given fields: vmInput
func (_m *MockManagedTypesContext) PopBackTransferIfAsyncCallBack(vmInput *vmcommon.ContractCallInput) {
	_m.Called(vmInput)
}

// PopDiscard provides a mock function with no fields
func (_m *MockManagedTypesContext) PopDiscard() {
	_m.Called()
}

// PopSetActiveState provides a mock function with no fields
func (_m *MockManagedTypesContext) PopSetActiveState() {
	_m.Called()
}

// PushState provides a mock function with no fields
func (_m *MockManagedTypesContext) PushState() {
	_m.Called()
}

// PutBigFloat provides a mock function with given fields: value
func (_m *MockManagedTypesContext) PutBigFloat(value *big.Float) (int32, error) {
	ret := _m.Called(value)

	if len(ret) == 0 {
		panic("no return value specified for PutBigFloat")
	}

	var r0 int32
	var r1 error
	if rf, ok := ret.Get(0).(func(*big.Float) (int32, error)); ok {
		return rf(value)
	}
	if rf, ok := ret.Get(0).(func(*big.Float) int32); ok {
		r0 = rf(value)
	} else {
		r0 = ret.Get(0).(int32)
	}

	if rf, ok := ret.Get(1).(func(*big.Float) error); ok {
		r1 = rf(value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutEllipticCurve provides a mock function with given fields: ec
func (_m *MockManagedTypesContext) PutEllipticCurve(ec *elliptic.CurveParams) int32 {
	ret := _m.Called(ec)

	if len(ret) == 0 {
		panic("no return value specified for PutEllipticCurve")
	}

	var r0 int32
	if rf, ok := ret.Get(0).(func(*elliptic.CurveParams) int32); ok {
		r0 = rf(ec)
	} else {
		r0 = ret.Get(0).(int32)
	}

	return r0
}

// ReadManagedVecOfManagedBuffers provides a mock function with given fields: managedVecHandle
func (_m *MockManagedTypesContext) ReadManagedVecOfManagedBuffers(managedVecHandle int32) ([][]byte, uint64, error) {
	ret := _m.Called(managedVecHandle)

	if len(ret) == 0 {
		panic("no return value specified for ReadManagedVecOfManagedBuffers")
	}

	var r0 [][]byte
	var r1 uint64
	var r2 error
	if rf, ok := ret.Get(0).(func(int32) ([][]byte, uint64, error)); ok {
		return rf(managedVecHandle)
	}
	if rf, ok := ret.Get(0).(func(int32) [][]byte); ok {
		r0 = rf(managedVecHandle)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(int32) uint64); ok {
		r1 = rf(managedVecHandle)
	} else {
		r1 = ret.Get(1).(uint64)
	}

	if rf, ok := ret.Get(2).(func(int32) error); ok {
		r2 = rf(managedVecHandle)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SetBytes provides a mock function with given fields: mBufferHandle, bytes
func (_m *MockManagedTypesContext) SetBytes(mBufferHandle int32, bytes []byte) {
	_m.Called(mBufferHandle, bytes)
}

// WriteManagedVecOfManagedBuffers provides a mock function with given fields: data, destinationHandle
func (_m *MockManagedTypesContext) WriteManagedVecOfManagedBuffers(data [][]byte, destinationHandle int32) error {
	ret := _m.Called(data, destinationHandle)

	if len(ret) == 0 {
		panic("no return value specified for WriteManagedVecOfManagedBuffers")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([][]byte, int32) error); ok {
		r0 = rf(data, destinationHandle)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewMockManagedTypesContext creates a new instance of MockManagedTypesContext. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockManagedTypesContext(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockManagedTypesContext {
	mock := &MockManagedTypesContext{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
