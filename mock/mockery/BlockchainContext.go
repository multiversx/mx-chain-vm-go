package mockery

import (
	big "math/big"

	esdt "github.com/multiversx/mx-chain-core-go/data/esdt"
	mock "github.com/stretchr/testify/mock"

	vmcommon "github.com/multiversx/mx-chain-vm-common-go"
)

// MockBlockchainContext is an autogenerated mock type for the BlockchainContext type
type MockBlockchainContext struct {
	mock.Mock
}

// AccountExists provides a mock function with given fields: addr
func (_m *MockBlockchainContext) AccountExists(addr []byte) bool {
	ret := _m.Called(addr)

	if len(ret) == 0 {
		return false
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func([]byte) bool); ok {
		r0 = rf(addr)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// BlockHash provides a mock function with given fields: number
func (_m *MockBlockchainContext) BlockHash(number uint64) []byte {
	ret := _m.Called(number)

	if len(ret) == 0 {
		return []byte("hash")
	}

	var r0 []byte
	if rf, ok := ret.Get(0).(func(uint64) []byte); ok {
		r0 = rf(number)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// ClearCompiledCodes provides a mock function with no fields
func (_m *MockBlockchainContext) ClearCompiledCodes() {
	_m.Called()
}

// ClearStateStack provides a mock function with no fields
func (_m *MockBlockchainContext) ClearStateStack() {
	_m.Called()
}

// CurrentEpoch provides a mock function with no fields
func (_m *MockBlockchainContext) CurrentEpoch() uint32 {
	ret := _m.Called()

	if len(ret) == 0 {
		return 1
	}

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// CurrentNonce provides a mock function with no fields
func (_m *MockBlockchainContext) CurrentNonce() uint64 {
	ret := _m.Called()

	if len(ret) == 0 {
		return 1
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// CurrentRandomSeed provides a mock function with no fields
func (_m *MockBlockchainContext) CurrentRandomSeed() []byte {
	ret := _m.Called()

	if len(ret) == 0 {
		return []byte("hash")
	}

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// CurrentRound provides a mock function with no fields
func (_m *MockBlockchainContext) CurrentRound() uint64 {
	ret := _m.Called()

	if len(ret) == 0 {
		return 1
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// CurrentTimeStamp provides a mock function with no fields
func (_m *MockBlockchainContext) CurrentTimeStamp() uint64 {
	ret := _m.Called()

	if len(ret) == 0 {
		return 1
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// CurrentTimeStampMs provides a mock function with no fields
func (_m *MockBlockchainContext) CurrentTimeStampMs() uint64 {
	ret := _m.Called()

	if len(ret) == 0 {
		return 1000
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// EpochStartBlockNonce provides a mock function with no fields
func (_m *MockBlockchainContext) EpochStartBlockNonce() uint64 {
	ret := _m.Called()

	if len(ret) == 0 {
		return 1
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// EpochStartBlockRound provides a mock function with no fields
func (_m *MockBlockchainContext) EpochStartBlockRound() uint64 {
	ret := _m.Called()

	if len(ret) == 0 {
		return 1
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// EpochStartBlockTimeStampMs provides a mock function with no fields
func (_m *MockBlockchainContext) EpochStartBlockTimeStampMs() uint64 {
	ret := _m.Called()

	if len(ret) == 0 {
		return 1
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// ExecuteSmartContractCallOnOtherVM provides a mock function with given fields: input
func (_m *MockBlockchainContext) ExecuteSmartContractCallOnOtherVM(input *vmcommon.ContractCallInput) (*vmcommon.VMOutput, error) {
	ret := _m.Called(input)

	if len(ret) == 0 {
		return &vmcommon.VMOutput{}, nil
	}

	var r0 *vmcommon.VMOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*vmcommon.ContractCallInput) (*vmcommon.VMOutput, error)); ok {
		return rf(input)
	}
	if rf, ok := ret.Get(0).(func(*vmcommon.ContractCallInput) *vmcommon.VMOutput); ok {
		r0 = rf(input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vmcommon.VMOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*vmcommon.ContractCallInput) error); ok {
		r1 = rf(input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBalance provides a mock function with given fields: addr
func (_m *MockBlockchainContext) GetBalance(addr []byte) []byte {
	ret := _m.Called(addr)

	if len(ret) == 0 {
		return big.NewInt(1).Bytes()
	}

	var r0 []byte
	if rf, ok := ret.Get(0).(func([]byte) []byte); ok {
		r0 = rf(addr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// GetBalanceBigInt provides a mock function with given fields: addr
func (_m *MockBlockchainContext) GetBalanceBigInt(addr []byte) *big.Int {
	ret := _m.Called(addr)

	if len(ret) == 0 {
		return big.NewInt(1)
	}

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func([]byte) *big.Int); ok {
		r0 = rf(addr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	return r0
}

// GetCode provides a mock function with given fields: addr
func (_m *MockBlockchainContext) GetCode(addr []byte) ([]byte, error) {
	ret := _m.Called(addr)

	if len(ret) == 0 {
		return []byte("code"), nil
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte) ([]byte, error)); ok {
		return rf(addr)
	}
	if rf, ok := ret.Get(0).(func([]byte) []byte); ok {
		r0 = rf(addr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(addr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCodeHash provides a mock function with given fields: addr
func (_m *MockBlockchainContext) GetCodeHash(addr []byte) []byte {
	ret := _m.Called(addr)

	if len(ret) == 0 {
		return []byte("hash")
	}

	var r0 []byte
	if rf, ok := ret.Get(0).(func([]byte) []byte); ok {
		r0 = rf(addr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// GetCodeSize provides a mock function with given fields: addr
func (_m *MockBlockchainContext) GetCodeSize(addr []byte) (int32, error) {
	ret := _m.Called(addr)

	if len(ret) == 0 {
		return 1, nil
	}

	var r0 int32
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte) (int32, error)); ok {
		return rf(addr)
	}
	if rf, ok := ret.Get(0).(func([]byte) int32); ok {
		r0 = rf(addr)
	} else {
		r0 = ret.Get(0).(int32)
	}

	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(addr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCompiledCode provides a mock function with given fields: codeHash
func (_m *MockBlockchainContext) GetCompiledCode(codeHash []byte) (bool, []byte) {
	ret := _m.Called(codeHash)

	if len(ret) == 0 {
		return true, []byte("hash")
	}

	var r0 bool
	var r1 []byte
	if rf, ok := ret.Get(0).(func([]byte) (bool, []byte)); ok {
		return rf(codeHash)
	}
	if rf, ok := ret.Get(0).(func([]byte) bool); ok {
		r0 = rf(codeHash)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([]byte) []byte); ok {
		r1 = rf(codeHash)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]byte)
		}
	}

	return r0, r1
}

// GetESDTToken provides a mock function with given fields: address, tokenID, nonce
func (_m *MockBlockchainContext) GetESDTToken(address []byte, tokenID []byte, nonce uint64) (*esdt.ESDigitalToken, error) {
	ret := _m.Called(address, tokenID, nonce)

	if len(ret) == 0 {
		return &esdt.ESDigitalToken{Value: big.NewInt(0)}, nil
	}

	var r0 *esdt.ESDigitalToken
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte, []byte, uint64) (*esdt.ESDigitalToken, error)); ok {
		return rf(address, tokenID, nonce)
	}
	if rf, ok := ret.Get(0).(func([]byte, []byte, uint64) *esdt.ESDigitalToken); ok {
		r0 = rf(address, tokenID, nonce)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*esdt.ESDigitalToken)
		}
	}

	if rf, ok := ret.Get(1).(func([]byte, []byte, uint64) error); ok {
		r1 = rf(address, tokenID, nonce)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNonce provides a mock function with given fields: addr
func (_m *MockBlockchainContext) GetNonce(addr []byte) (uint64, error) {
	ret := _m.Called(addr)

	if len(ret) == 0 {
		return 1, nil
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte) (uint64, error)); ok {
		return rf(addr)
	}
	if rf, ok := ret.Get(0).(func([]byte) uint64); ok {
		r0 = rf(addr)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(addr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetOwnerAddress provides a mock function with no fields
func (_m *MockBlockchainContext) GetOwnerAddress() ([]byte, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		return []byte("address"), nil
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]byte, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetShardOfAddress provides a mock function with given fields: addr
func (_m *MockBlockchainContext) GetShardOfAddress(addr []byte) uint32 {
	ret := _m.Called(addr)

	if len(ret) == 0 {
		return 0
	}

	var r0 uint32
	if rf, ok := ret.Get(0).(func([]byte) uint32); ok {
		r0 = rf(addr)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// GetSnapshot provides a mock function with no fields
func (_m *MockBlockchainContext) GetSnapshot() int {
	ret := _m.Called()

	if len(ret) == 0 {
		return 0
	}

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// GetStateRootHash provides a mock function with no fields
func (_m *MockBlockchainContext) GetStateRootHash() []byte {
	ret := _m.Called()

	if len(ret) == 0 {
		return []byte("root")
	}

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// GetUserAccount provides a mock function with given fields: address
func (_m *MockBlockchainContext) GetUserAccount(address []byte) (vmcommon.UserAccountHandler, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetUserAccount")
	}

	var r0 vmcommon.UserAccountHandler
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte) (vmcommon.UserAccountHandler, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func([]byte) vmcommon.UserAccountHandler); ok {
		r0 = rf(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(vmcommon.UserAccountHandler)
		}
	}

	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IncreaseNonce provides a mock function with given fields: addr
func (_m *MockBlockchainContext) IncreaseNonce(addr []byte) {
	_m.Called(addr)
}

// InitState provides a mock function with no fields
func (_m *MockBlockchainContext) InitState() {
	_m.Called()
}

// IsLimitedTransfer provides a mock function with given fields: tokenID
func (_m *MockBlockchainContext) IsLimitedTransfer(tokenID []byte) bool {
	ret := _m.Called(tokenID)

	if len(ret) == 0 {
		return false
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func([]byte) bool); ok {
		r0 = rf(tokenID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsPaused provides a mock function with given fields: tokenID
func (_m *MockBlockchainContext) IsPaused(tokenID []byte) bool {
	ret := _m.Called(tokenID)

	if len(ret) == 0 {
		return false
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func([]byte) bool); ok {
		r0 = rf(tokenID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsPayable provides a mock function with given fields: sndAddress, rcvAddress
func (_m *MockBlockchainContext) IsPayable(sndAddress []byte, rcvAddress []byte) (bool, error) {
	ret := _m.Called(sndAddress, rcvAddress)

	if len(ret) == 0 {
		return true, nil
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte, []byte) (bool, error)); ok {
		return rf(sndAddress, rcvAddress)
	}
	if rf, ok := ret.Get(0).(func([]byte, []byte) bool); ok {
		r0 = rf(sndAddress, rcvAddress)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([]byte, []byte) error); ok {
		r1 = rf(sndAddress, rcvAddress)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsSmartContract provides a mock function with given fields: addr
func (_m *MockBlockchainContext) IsSmartContract(addr []byte) bool {
	ret := _m.Called(addr)

	if len(ret) == 0 {
		return true
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func([]byte) bool); ok {
		r0 = rf(addr)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// LastEpoch provides a mock function with no fields
func (_m *MockBlockchainContext) LastEpoch() uint32 {
	ret := _m.Called()

	if len(ret) == 0 {
		return 1
	}

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// LastNonce provides a mock function with no fields
func (_m *MockBlockchainContext) LastNonce() uint64 {
	ret := _m.Called()

	if len(ret) == 0 {
		return 1
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// LastRandomSeed provides a mock function with no fields
func (_m *MockBlockchainContext) LastRandomSeed() []byte {
	ret := _m.Called()

	if len(ret) == 0 {
		return []byte("random")
	}

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// LastRound provides a mock function with no fields
func (_m *MockBlockchainContext) LastRound() uint64 {
	ret := _m.Called()

	if len(ret) == 0 {
		return 1
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// LastTimeStamp provides a mock function with no fields
func (_m *MockBlockchainContext) LastTimeStamp() uint64 {
	ret := _m.Called()

	if len(ret) == 0 {
		return 1
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// LastTimeStampMs provides a mock function with no fields
func (_m *MockBlockchainContext) LastTimeStampMs() uint64 {
	ret := _m.Called()

	if len(ret) == 0 {
		return 1000
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// NewAddress provides a mock function with given fields: creatorAddress
func (_m *MockBlockchainContext) NewAddress(creatorAddress []byte) ([]byte, error) {
	ret := _m.Called(creatorAddress)

	if len(ret) == 0 {
		return []byte("addr"), nil
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte) ([]byte, error)); ok {
		return rf(creatorAddress)
	}
	if rf, ok := ret.Get(0).(func([]byte) []byte); ok {
		r0 = rf(creatorAddress)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(creatorAddress)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PopDiscard provides a mock function with no fields
func (_m *MockBlockchainContext) PopDiscard() {
	_m.Called()
}

// PopSetActiveState provides a mock function with no fields
func (_m *MockBlockchainContext) PopSetActiveState() {
	_m.Called()
}

// ProcessBuiltInFunction provides a mock function with given fields: input
func (_m *MockBlockchainContext) ProcessBuiltInFunction(input *vmcommon.ContractCallInput) (*vmcommon.VMOutput, error) {
	ret := _m.Called(input)

	if len(ret) == 0 {
		return &vmcommon.VMOutput{}, nil
	}

	var r0 *vmcommon.VMOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(*vmcommon.ContractCallInput) (*vmcommon.VMOutput, error)); ok {
		return rf(input)
	}
	if rf, ok := ret.Get(0).(func(*vmcommon.ContractCallInput) *vmcommon.VMOutput); ok {
		r0 = rf(input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vmcommon.VMOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(*vmcommon.ContractCallInput) error); ok {
		r1 = rf(input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PushState provides a mock function with no fields
func (_m *MockBlockchainContext) PushState() {
	_m.Called()
}

// RevertToSnapshot provides a mock function with given fields: snapshot
func (_m *MockBlockchainContext) RevertToSnapshot(snapshot int) {
	_m.Called(snapshot)
}

// RoundTime provides a mock function with no fields
func (_m *MockBlockchainContext) RoundTime() uint64 {
	ret := _m.Called()

	if len(ret) == 0 {
		return 0
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// SaveCompiledCode provides a mock function with given fields: codeHash, code
func (_m *MockBlockchainContext) SaveCompiledCode(codeHash []byte, code []byte) {
	_m.Called(codeHash, code)
}

// NewMockBlockchainContext creates a new instance of MockBlockchainContext. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockBlockchainContext(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockBlockchainContext {
	mock := &MockBlockchainContext{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
