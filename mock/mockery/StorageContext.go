package mockery

import (
	vmcommon "github.com/multiversx/mx-chain-vm-common-go"
	mock "github.com/stretchr/testify/mock"

	vmhost "github.com/multiversx/mx-chain-vm-go/vmhost"
)

// MockStorageContext is an autogenerated mock type for the StorageContext type
type MockStorageContext struct {
	mock.Mock
}

// ClearStateStack provides a mock function with no fields
func (_m *MockStorageContext) ClearStateStack() {
	_m.Called()
}

// GetStorage provides a mock function with given fields: key
func (_m *MockStorageContext) GetStorage(key []byte) ([]byte, uint32, bool, error) {
	ret := _m.Called(key)

	if len(ret) == 0 {
		return []byte{}, 1, false, nil
	}

	var r0 []byte
	var r1 uint32
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func([]byte) ([]byte, uint32, bool, error)); ok {
		return rf(key)
	}
	if rf, ok := ret.Get(0).(func([]byte) []byte); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func([]byte) uint32); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Get(1).(uint32)
	}

	if rf, ok := ret.Get(2).(func([]byte) bool); ok {
		r2 = rf(key)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func([]byte) error); ok {
		r3 = rf(key)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// GetStorageFromAddress provides a mock function with given fields: address, key
func (_m *MockStorageContext) GetStorageFromAddress(address []byte, key []byte) ([]byte, uint32, bool, error) {
	ret := _m.Called(address, key)

	if len(ret) == 0 {
		return []byte{}, 1, false, nil
	}

	var r0 []byte
	var r1 uint32
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func([]byte, []byte) ([]byte, uint32, bool, error)); ok {
		return rf(address, key)
	}
	if rf, ok := ret.Get(0).(func([]byte, []byte) []byte); ok {
		r0 = rf(address, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func([]byte, []byte) uint32); ok {
		r1 = rf(address, key)
	} else {
		r1 = ret.Get(1).(uint32)
	}

	if rf, ok := ret.Get(2).(func([]byte, []byte) bool); ok {
		r2 = rf(address, key)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func([]byte, []byte) error); ok {
		r3 = rf(address, key)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// GetStorageFromAddressNoChecks provides a mock function with given fields: address, key
func (_m *MockStorageContext) GetStorageFromAddressNoChecks(address []byte, key []byte) ([]byte, uint32, bool, error) {
	ret := _m.Called(address, key)

	if len(ret) == 0 {
		return []byte{}, 1, false, nil
	}

	var r0 []byte
	var r1 uint32
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func([]byte, []byte) ([]byte, uint32, bool, error)); ok {
		return rf(address, key)
	}
	if rf, ok := ret.Get(0).(func([]byte, []byte) []byte); ok {
		r0 = rf(address, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func([]byte, []byte) uint32); ok {
		r1 = rf(address, key)
	} else {
		r1 = ret.Get(1).(uint32)
	}

	if rf, ok := ret.Get(2).(func([]byte, []byte) bool); ok {
		r2 = rf(address, key)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func([]byte, []byte) error); ok {
		r3 = rf(address, key)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// GetStorageUnmetered provides a mock function with given fields: key
func (_m *MockStorageContext) GetStorageUnmetered(key []byte) ([]byte, uint32, bool, error) {
	ret := _m.Called(key)

	if len(ret) == 0 {
		return []byte{}, 1, false, nil
	}

	var r0 []byte
	var r1 uint32
	var r2 bool
	var r3 error
	if rf, ok := ret.Get(0).(func([]byte) ([]byte, uint32, bool, error)); ok {
		return rf(key)
	}
	if rf, ok := ret.Get(0).(func([]byte) []byte); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func([]byte) uint32); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Get(1).(uint32)
	}

	if rf, ok := ret.Get(2).(func([]byte) bool); ok {
		r2 = rf(key)
	} else {
		r2 = ret.Get(2).(bool)
	}

	if rf, ok := ret.Get(3).(func([]byte) error); ok {
		r3 = rf(key)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// GetStorageUpdates provides a mock function with given fields: address
func (_m *MockStorageContext) GetStorageUpdates(address []byte) map[string]*vmcommon.StorageUpdate {
	ret := _m.Called(address)

	if len(ret) == 0 {
		return map[string]*vmcommon.StorageUpdate{}
	}

	var r0 map[string]*vmcommon.StorageUpdate
	if rf, ok := ret.Get(0).(func([]byte) map[string]*vmcommon.StorageUpdate); ok {
		r0 = rf(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]*vmcommon.StorageUpdate)
		}
	}

	return r0
}

// GetVmProtectedPrefix provides a mock function with given fields: prefix
func (_m *MockStorageContext) GetVmProtectedPrefix(prefix string) []byte {
	ret := _m.Called(prefix)

	if len(ret) == 0 {
		return []byte("VM")
	}

	var r0 []byte
	if rf, ok := ret.Get(0).(func(string) []byte); ok {
		r0 = rf(prefix)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// InitState provides a mock function with no fields
func (_m *MockStorageContext) InitState() {
	_m.Called()
}

// PopDiscard provides a mock function with no fields
func (_m *MockStorageContext) PopDiscard() {
	_m.Called()
}

// PopSetActiveState provides a mock function with no fields
func (_m *MockStorageContext) PopSetActiveState() {
	_m.Called()
}

// PushState provides a mock function with no fields
func (_m *MockStorageContext) PushState() {
	_m.Called()
}

// SetAddress provides a mock function with given fields: address
func (_m *MockStorageContext) SetAddress(address []byte) {
	_m.Called(address)
}

// SetProtectedStorage provides a mock function with given fields: key, value
func (_m *MockStorageContext) SetProtectedStorage(key []byte, value []byte) (vmhost.StorageStatus, error) {
	ret := _m.Called(key, value)

	if len(ret) == 0 {
		return 0, nil
	}

	var r0 vmhost.StorageStatus
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte, []byte) (vmhost.StorageStatus, error)); ok {
		return rf(key, value)
	}
	if rf, ok := ret.Get(0).(func([]byte, []byte) vmhost.StorageStatus); ok {
		r0 = rf(key, value)
	} else {
		r0 = ret.Get(0).(vmhost.StorageStatus)
	}

	if rf, ok := ret.Get(1).(func([]byte, []byte) error); ok {
		r1 = rf(key, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetProtectedStorageToAddress provides a mock function with given fields: address, key, value
func (_m *MockStorageContext) SetProtectedStorageToAddress(address []byte, key []byte, value []byte) (vmhost.StorageStatus, error) {
	ret := _m.Called(address, key, value)

	if len(ret) == 0 {
		return 0, nil
	}

	var r0 vmhost.StorageStatus
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte, []byte, []byte) (vmhost.StorageStatus, error)); ok {
		return rf(address, key, value)
	}
	if rf, ok := ret.Get(0).(func([]byte, []byte, []byte) vmhost.StorageStatus); ok {
		r0 = rf(address, key, value)
	} else {
		r0 = ret.Get(0).(vmhost.StorageStatus)
	}

	if rf, ok := ret.Get(1).(func([]byte, []byte, []byte) error); ok {
		r1 = rf(address, key, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetProtectedStorageToAddressUnmetered provides a mock function with given fields: address, key, value
func (_m *MockStorageContext) SetProtectedStorageToAddressUnmetered(address []byte, key []byte, value []byte) (vmhost.StorageStatus, error) {
	ret := _m.Called(address, key, value)

	if len(ret) == 0 {
		return 0, nil
	}

	var r0 vmhost.StorageStatus
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte, []byte, []byte) (vmhost.StorageStatus, error)); ok {
		return rf(address, key, value)
	}
	if rf, ok := ret.Get(0).(func([]byte, []byte, []byte) vmhost.StorageStatus); ok {
		r0 = rf(address, key, value)
	} else {
		r0 = ret.Get(0).(vmhost.StorageStatus)
	}

	if rf, ok := ret.Get(1).(func([]byte, []byte, []byte) error); ok {
		r1 = rf(address, key, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetStorage provides a mock function with given fields: key, value
func (_m *MockStorageContext) SetStorage(key []byte, value []byte) (vmhost.StorageStatus, error) {
	ret := _m.Called(key, value)

	if len(ret) == 0 {
		return 0, nil
	}

	var r0 vmhost.StorageStatus
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte, []byte) (vmhost.StorageStatus, error)); ok {
		return rf(key, value)
	}
	if rf, ok := ret.Get(0).(func([]byte, []byte) vmhost.StorageStatus); ok {
		r0 = rf(key, value)
	} else {
		r0 = ret.Get(0).(vmhost.StorageStatus)
	}

	if rf, ok := ret.Get(1).(func([]byte, []byte) error); ok {
		r1 = rf(key, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UseGasForStorageLoad provides a mock function with given fields: tracedFunctionName, trieDepth, blockchainLoadCost, usedCache
func (_m *MockStorageContext) UseGasForStorageLoad(tracedFunctionName string, trieDepth int64, blockchainLoadCost uint64, usedCache bool) error {
	ret := _m.Called(tracedFunctionName, trieDepth, blockchainLoadCost, usedCache)

	if len(ret) == 0 {
		return nil
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, int64, uint64, bool) error); ok {
		r0 = rf(tracedFunctionName, trieDepth, blockchainLoadCost, usedCache)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewMockStorageContext creates a new instance of MockStorageContext. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStorageContext(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStorageContext {
	mock := &MockStorageContext{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
