// Code generated by mockery v2.53.4. DO NOT EDIT.

package mockery

import (
	executor "github.com/multiversx/mx-chain-vm-go/executor"
	mock "github.com/stretchr/testify/mock"
)

// MockInstance is an autogenerated mock type for the Instance type
type MockInstance struct {
	mock.Mock
}

// Cache provides a mock function with no fields
func (_m *MockInstance) Cache() ([]byte, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Cache")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]byte, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CallFunction provides a mock function with given fields: functionName
func (_m *MockInstance) CallFunction(functionName string) error {
	ret := _m.Called(functionName)

	if len(ret) == 0 {
		panic("no return value specified for CallFunction")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(functionName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Clean provides a mock function with no fields
func (_m *MockInstance) Clean() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Clean")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// GetBreakpointValue provides a mock function with no fields
func (_m *MockInstance) GetBreakpointValue() uint64 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetBreakpointValue")
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// GetFunctionNames provides a mock function with no fields
func (_m *MockInstance) GetFunctionNames() []string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetFunctionNames")
	}

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// GetPointsUsed provides a mock function with no fields
func (_m *MockInstance) GetPointsUsed() uint64 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetPointsUsed")
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// GetVMHooksPtr provides a mock function with no fields
func (_m *MockInstance) GetVMHooksPtr() uintptr {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetVMHooksPtr")
	}

	var r0 uintptr
	if rf, ok := ret.Get(0).(func() uintptr); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uintptr)
	}

	return r0
}

// HasFunction provides a mock function with given fields: functionName
func (_m *MockInstance) HasFunction(functionName string) bool {
	ret := _m.Called(functionName)

	if len(ret) == 0 {
		panic("no return value specified for HasFunction")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(functionName)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// HasMemory provides a mock function with no fields
func (_m *MockInstance) HasMemory() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for HasMemory")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// ID provides a mock function with no fields
func (_m *MockInstance) ID() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ID")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// IsAlreadyCleaned provides a mock function with no fields
func (_m *MockInstance) IsAlreadyCleaned() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsAlreadyCleaned")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsFunctionImported provides a mock function with given fields: name
func (_m *MockInstance) IsFunctionImported(name string) bool {
	ret := _m.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for IsFunctionImported")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsInterfaceNil provides a mock function with no fields
func (_m *MockInstance) IsInterfaceNil() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsInterfaceNil")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MemDump provides a mock function with no fields
func (_m *MockInstance) MemDump() []byte {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for MemDump")
	}

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// MemGrow provides a mock function with given fields: pages
func (_m *MockInstance) MemGrow(pages uint32) error {
	ret := _m.Called(pages)

	if len(ret) == 0 {
		panic("no return value specified for MemGrow")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint32) error); ok {
		r0 = rf(pages)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MemLength provides a mock function with no fields
func (_m *MockInstance) MemLength() uint32 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for MemLength")
	}

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// MemLoad provides a mock function with given fields: memPtr, length
func (_m *MockInstance) MemLoad(memPtr executor.MemPtr, length int32) ([]byte, error) {
	ret := _m.Called(memPtr, length)

	if len(ret) == 0 {
		panic("no return value specified for MemLoad")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(executor.MemPtr, int32) ([]byte, error)); ok {
		return rf(memPtr, length)
	}
	if rf, ok := ret.Get(0).(func(executor.MemPtr, int32) []byte); ok {
		r0 = rf(memPtr, length)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(executor.MemPtr, int32) error); ok {
		r1 = rf(memPtr, length)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MemStore provides a mock function with given fields: memPtr, data
func (_m *MockInstance) MemStore(memPtr executor.MemPtr, data []byte) error {
	ret := _m.Called(memPtr, data)

	if len(ret) == 0 {
		panic("no return value specified for MemStore")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(executor.MemPtr, []byte) error); ok {
		r0 = rf(memPtr, data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Reset provides a mock function with no fields
func (_m *MockInstance) Reset() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Reset")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// SetBreakpointValue provides a mock function with given fields: value
func (_m *MockInstance) SetBreakpointValue(value uint64) {
	_m.Called(value)
}

// SetGasLimit provides a mock function with given fields: gasLimit
func (_m *MockInstance) SetGasLimit(gasLimit uint64) {
	_m.Called(gasLimit)
}

// SetPointsUsed provides a mock function with given fields: points
func (_m *MockInstance) SetPointsUsed(points uint64) {
	_m.Called(points)
}

// SetVMHooksPtr provides a mock function with given fields: vmHooksPtr
func (_m *MockInstance) SetVMHooksPtr(vmHooksPtr uintptr) {
	_m.Called(vmHooksPtr)
}

// ValidateFunctionArities provides a mock function with no fields
func (_m *MockInstance) ValidateFunctionArities() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ValidateFunctionArities")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewMockInstance creates a new instance of MockInstance. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockInstance(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockInstance {
	mock := &MockInstance{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
